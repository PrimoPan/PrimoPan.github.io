[{"title":"Codeforces19D Points 树套树","url":"/2022/03/18/cf19d/","content":"Codeforces 19D Points\n\nPete and Bob invented a new interesting game. Bob takes a sheet of paper and locates a Cartesian coordinate system on it as follows: point (0, 0) is located in the bottom-left corner, Ox axis is directed right, Oy axis is directed up. Pete gives Bob requests of three types:\nadd x y — on the sheet of paper Bob marks a point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is not yet marked on Bob’s sheet at the time of the request.remove x y — on the sheet of paper Bob erases the previously marked point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is already marked on Bob’s sheet at the time of the request.find x y — on the sheet of paper Bob finds all the marked points, lying strictly above and strictly to the right of point (x, y). Among these points Bob chooses the leftmost one, if it is not unique, he chooses the bottommost one, and gives its coordinates to Pete.Bob managed to answer the requests, when they were 10, 100 or 1000, but when their amount grew up to 2·105, Bob failed to cope. Now he needs a program that will answer all Pete’s requests. Help Bob, please!\nInput\nThe first input line contains number n (1 ≤ n ≤ 2·105) — amount of requests. Then there follow n lines — descriptions of the requests. add x y describes the request to add a point, remove x y — the request to erase a point, find x y — the request to find the bottom-left point. All the coordinates in the input file are non-negative and don’t exceed 109.\nOutput\nFor each request of type find x y output in a separate line the answer to it — coordinates of the bottommost among the leftmost marked points, lying strictly above and to the right of point (x, y). If there are no points strictly above and to the right of point (x, y), output -1.\nExample\nInput\n7\nadd 1 1\nadd 3 4\nfind 0 0\nremove 1 1\nfind 0 0\nadd 1 1\nfind 0 0\nOutput\n1 1\n3 4\n1 1\nInput\n13\nadd 5 5\nadd 5 6\nadd 5 7\nadd 6 5\nadd 6 6\nadd 6 7\nadd 7 5\nadd 7 6\nadd 7 7\nfind 6 6\nremove 7 7\nfind 6 6\nfind 4 4\nOutput\n7 7\n-1\n5 5\n\n题目大意\n在平面直角坐标系上进行一堆骚操作。Add表示添加(x,y) Remove删除(x,y) Find(x,y)表示查询(x,y)右边的最左边的上面的最下面那个点……\n题解\n\n建一棵线段树，每个叶子节点维护一棵平衡树，平衡树里记录横坐标为x的纵坐标（横坐标较大我们可以先离散化），线段树维护横坐标在这个区间里的纵坐标的最大值，所以查询的时候只要这个线段树结点维护的key小于我们要找到y这个区间里就没有解，在key值符合条件的情况下找横坐标最左边的一个点，找到这个横坐标再在平衡树里找恰好比y大的那个点即可。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn (int)2e5+10#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1struct Opt{\tchar s[10];\tint x,y;}opt[maxn];struct SGT{\tint l,r,key;}T[maxn&lt;&lt;2];#define ll long longint n,a[maxn],b[maxn],c[maxn];set&lt;int&gt; S[maxn];set&lt;int&gt;::iterator it;inline void build(int o,int l,int r){\tif (l&gt;r) return ;\tT[o].l=l;T[o].r=r;T[o].key=-1;\tif (l==r)return ;\tint mid=(l+r)&gt;&gt;1;\tbuild(lson,l,mid);build(rson,mid+1,r);\tT[o].key=max(T[lson].key,T[rson].key);}inline void update(int o,int x){\tint mid=(T[o].l+T[o].r)&gt;&gt;1;\tif (T[o].l==T[o].r &amp;&amp; T[o].l==x)\t{\t\tif (S[T[o].l].size())\t\t{\t\t\tit=(--S[T[o].l].end());\t\t\tT[o].key=*it;\t\t}\t\telse T[o].key=-1;\t\treturn ;\t}\tif (mid&gt;=x) update(lson,x);\telse update(rson,x);\tT[o].key=max(T[lson].key,T[rson].key);}inline int query(int o,int x,int y){\tif (T[o].r&lt;=x) return -1;\tif (T[o].key&lt;=y) return -1;\tif (T[o].l==T[o].r) return T[o].r;\tint t=query(lson,x,y);\tif (t==-1) return query(rson,x,y);\treturn t;}int cnt=0,ct2;int main(){\tcin&gt;&gt;n;\tfor (int i=1;i&lt;=n;i++)\t{\t\tscanf(\"%s%d%d\",opt[i].s,&amp;opt[i].x,&amp;opt[i].y);\t\ta[i]=opt[i].x;\t}\tsort(a+1,a+1+n);\tint t=unique(a+1,a+1+n)-a-1;\tfor (int i=1;i&lt;=n;i++) b[i]=lower_bound(a+1,a+1+t,opt[i].x)-a;\tbuild(1,1,maxn);\tfor (int i=1;i&lt;=n;i++)\t{\t\tif (opt[i].s[0]=='a')\t\t{\t\t\tS[b[i]].insert(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}else\t\tif (opt[i].s[0]=='r')\t\t{\t\t\tS[b[i]].erase(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}\t\telse{\t\t\tint ans=query(1,b[i],opt[i].y);\t\t\tif (ans==-1) cout&lt;&lt;-1&lt;&lt;endl;\t\t\telse{\t\t\t\tprintf(\"%d %d\\n\",a[ans],*S[ans].upper_bound(opt[i].y));\t\t\t}\t\t}\t}}","categories":["算法竞赛"],"tags":["线段树","树套树","数据结构","Codeforces"]},{"title":"codeforces 24D Broken Robot[有后效性DP,高斯消元]","url":"/2022/03/19/cf24d/","content":"来自lyd的书，给定一张N*M的棋盘和一个初始位置，机器人位于初始位置，每次等概率地选择停在原地，向左移动一格或者向下移动一格。不能移出棋盘，求机器人从初始位置走到最后一行的任意一个位置的数学期望。（1&lt;=N,M&lt;=1,000)。\n注意很多数学期望DP都会采取倒推的方式进行我们记F[i][j]表示从(i,j)走到最后一行所需要的期望值\n位于第一列\n位于最后一列\n剩余情况\n因为每一行内部可以相互转移，所以这个dp是有后效性的，但从下一行往上一行推的过程无后效性，对于行内有后效性的转移，使用高斯消元，将下一行已经得到的数据作为已知量。通过将这些方程移项可以推出很多方程组，将它们用矩阵表示，以M=5为例\n\n观察后发现这种矩阵叫 三对角矩阵每一行消元只需要直接用下一行相邻的数据进行一次消元就行了，复杂度是线性的，加上每一行往上的无后效性递推，总体的复杂度是O(NM)。注意到M=1的时候要进行特殊处理，将第一个方程带入消元后发现每一行等于下一行的期望+2。在消元过程中很多细节的加加减减和系数处理都要在纸上列出算式消元后才能处理，要注意。\n\ndouble f[maxn],a[maxn][maxn],b[maxn];int n,m,x,y; void gauss(){\tfor (int i=1;i&lt;m;i++)\t{\t\tdouble rt=a[i+1][i]/a[i][i];\t\ta[i+1][i]-=rt*a[i][i];\t\ta[i+1][i+1]-=rt*a[i][i+1];\t\tb[i+1]-=rt*b[i];\t}\tf[m]=b[m]/a[m][m];\tfor (int i=m-1;i&gt;=1;i--)\t{\t\tf[i]=(b[i]-f[i+1]*a[i][i+1])/a[i][i];\t}}//mainint main(){\t//freopen(\"Untitled.txt.in\",\"r\",stdin);\t//freopen(\"Untitled.txt.out\",\"w\",stdout);\tios::sync_with_stdio(false);\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;\tif (m==1)\t{\t\tdouble ans= (double) (n-x) *2;\t\tcout&lt;&lt;ans&lt;&lt;endl;\t\treturn 0;\t}\tfor (int i=n-1;i&gt;=x;i--)\t{\t\ta[1][1]=(double)-2/3;\t\ta[1][2]=(double)1/3;\t\ta[m][m-1]=(double)1/3;\t\ta[m][m]=(double)-2/3;\t\tb[1]=(double)((double)-1/3)*f[1]-1;\t\tb[m]=(double)((double)-1/3)*f[m]-1;\t\tfor (int j=2;j&lt;m;j++)\t\t{\t\t\ta[j][j-1]=a[j][j+1]=(double)1/4;\t\t\ta[j][j]=(double)-3/4;\t\t\tb[j]=(double)((double)-1/4)*f[j]-1;\t\t}\t\tgauss();\t\t}\t\tcout&lt;&lt;setprecision(10)&lt;&lt;f[y]&lt;&lt;endl;\treturn 0;}","categories":["算法竞赛"],"tags":["Codeforces","动态规划","有后效性动态规划","高斯消元"]},{"title":"Javascript在宿主软件中演奏软件乐器","url":"/2022/03/18/Javascript%E5%9C%A8%E5%AE%BF%E4%B8%BB%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%BC%94%E5%A5%8F%E8%BD%AF%E4%BB%B6%E4%B9%90%E5%99%A8/","content":"JS与Logic Pro X这样的编曲宿主软件实现通信，听起来就是一个很酷的功能，这意味着你编曲时使用的MIDI信号完全可以由代码生成。尤其是有了p5和tf.js之类的前端库，在人机交互时可以将交互时产生的信号映射成MIDI信号生成音乐。\nWebMidi库就是一个可以实现JS与MIDI设备通信的Javascript库。相当于在浏览器和MIDI设备之间架起了一座桥梁。我们通过Macbook系统自带的虚拟MIDI设备IAC Driver可以直接与编曲软件Logic Pro进行通信。\n 在 启动台-其他中找到音频MIDI设置\n\nCommand+2打开MIDI工作室窗口，选定Bus 1端口，Apply！\n\n然后打开Logic，新建软件乐器轨道，这个时候我们通过JS写的代码就可以通过虚拟MIDI导入到Logic中了\n接下来编写代码，因为WebMidi基于http协议，我们需要把一个html文件挂到本地服务器上，然后引入WebMidi库，CDN或本地化后皆可，我这里将WebMidi本地化了\n\n\n&lt;script src=\"webmidi.iife.js\"&gt;&lt;/script&gt;\n\n然后为WebMidi的初始化绑定一个事件，初始化函数如下\n\nfunction init(){    WebMidi.enable(err=&gt;    {        if (err) console.log(err);        WebMidi.outputs.forEach(output=&gt;{          if (output.name===\"IAC Driver Bus 1\")            window.output=output        })      },true)      startLoop()//开始循环}\n注意output.name要选定你的虚拟MIDI端口，然后在startLoop中我们就可以编写MIDI数据了\n我们演奏一个音需要用到output.playNote()方法，该函数有三个参数，第一个是音高（Note），你可以选择0～127之间任意一个整数，也可以直接以字符串的形式比如\"C#4\"来代表这个音，或者传入一个Note对象。第二个参数是轨道参数，记得在Logic中配置每个乐器的轨道名。第三个参数是一个对象，对象中可以修改time,attack,duration,release等参数，和我们混音时这些参数所代表的含义基本一致。\n下面是我第一次写的曲子，苏联时期新闻联播的主题曲《Forward Time》的一个小片段，制谱参考油管视频G. Sviridov - Time, Forward! | Piano Tutorial (100,000 special)。做了一个小demo，写到了副歌，感觉效果还行。有了这个基础，去制作更有意思的与音乐有关的前端交互作品便成了可能。\n\nfunction startLoop()    {      var step=1;      var step2=1;      setInterval(()=&gt;{        if (step2/16&lt;12) {          if (step === 1 || step === 9)            output.playNote(\"E2\", 1, {duration: 200, attack: 0.8})          if (step === 3 || step === 11)            output.playNote(\"G2\", 1, {duration: 200, attack: 0.8})          if (step === 5 || step === 13)            output.playNote(\"A#2\", 1, {duration: 200, attack: 0.8})          if (step === 7 || step === 15)            output.playNote(\"C#3\", 1, {duration: 200, attack: 0.8})        }        if ((step2/16&gt;=4 &amp;&amp; step2/16&lt;5)||(step2/16&gt;=6 &amp;&amp; step2/16&lt;7))        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:1100,attack:0.9})            output.playNote(\"A#3\",2,{duration:1100,attack:0.9})            output.playNote(\"C#3\",2,{duration:1100,attack:0.9})          }        }        if (step2/16&gt;=8 &amp;&amp; step2/16&lt;9)        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=9 &amp;&amp; step2/16&lt;11)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=11 &amp;&amp; step2/16&lt;12)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=12 &amp;&amp; step2/16&lt;18)        {          if (step%2===1)          {            output.playNote(\"F#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})            output.playNote(\"C#4\",1,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=14 &amp;&amp; step2/16&lt;15)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=15 &amp;&amp; step2/16&lt;16)        {          if (step===1) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1)          {            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=17 &amp;&amp; step2/16&lt;18)        {          if (step===1) {            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 300, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 300, attack: 0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;20)        {          if (step%2===1)          {            output.playNote(\"A#2\",1,{duration:100,attack:0.9})            output.playNote(\"D#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;19)        {          if (step===1){          output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"F#6\", 2, {duration: 1500, attack: 0.9})        }}        if (step2/16&gt;=19 &amp;&amp; step2/16&lt;20)        {          if (step===1){            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }          if (step===9){            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=20 &amp;&amp; step2/16&lt;21)        {          if (step===1){            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"G#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }}        if (step2/16&gt;=20 )        {          if (step%2===1)          {            output.playNote(\"C#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})          }        }step++;        if (step&gt;16)step=1;        step2++;       // step2++;        //if (step2&gt;32) step2=1      },100)    }","categories":["大前端"],"tags":["前端","Javascript","音乐","编曲"]},{"title":"hello-world","url":"/2022/03/18/hello-world/","content":"好像有那么几年不写blog了...为了督促自己继续努力刷题/学习还是在这里开了一个，github.io真的方便，会在这里记录一些学习的历程和各种碎碎念。那么继续温柔地推翻这个世界吧～\n#include &lt;bits/stdc++.h&gt;int main(){    std:cout&lt;&lt;\"Hello World\"&lt;&lt;endl;}","categories":["生活和碎碎念"],"tags":["碎碎念"]},{"title":"浙工大校赛-puzzle-Hash","url":"/2022/03/22/22-3-puzzle/","content":"\n题目大意\n\n    给三个长度为n(1&lt;=n&lt;=100 000)的数组A,B,C。可以将A数组或者B数组左移，每次移动记一次操作，问最少多少次操作可以使得Ai+Bi=Ci，否则扣-1。\n\n题解\n\n 比赛的时候脑子抽了...推了一个非充要条件，然后看有点假，想想会不会是字符串相关的题，然后去做核酸了。\n\n\n    后来发现很假，直接环形哈希就完事儿了。带上map复杂度是的。\n\n//This amazing code is written by Primo.Jay.Pan From CUC//Any questions please contact me//QQ:898021802//Mail: primojpan@gmail.com//.    primojaypan@cuc.edu.cn// Untitled 3.txt// Created by Primo Jay Pan on 2022/3/22.//While (true) RP++;//head#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;csignal&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int,int&gt;#define pll pair&lt;ll,ll&gt;#define INF 0x3f3f3f3f#define maxlongint 2147483647#define maxint 32767#define pi(double)acos(-1.0)#define eps 1e-9#define MID ((l+r)&gt;&gt;1)#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)//clear the array#define cla(a) memset(a,0,sizeof(a))#define clb(a) memset(a,INF,sizeof(a))#define clc(a) memset(a,-1,sizeof(a))using namespace std;const ull mod=998244353;const int maxn =100010; ull A[maxn],B[maxn],C[maxn],base[maxn];map&lt;ull , int &gt; MP;int n;inline void init(){\tbase[0]=1;\tfor (int i=1;i&lt;=n;i++)\t\tbase[i]=base[i-1]*mod;\t}int ans=mod;//mainint main(){\t//freopen(\"Untitled 3.txt.in\",\"r\",stdin);\t//freopen(\"Untitled 3.txt.out\",\"w\",stdout);\tcin&gt;&gt;n;\tinit();\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;A[i];\t\tA[i]=A[i-1]*mod+A[i];\t}\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;B[i];\t\tB[i]=B[i-1]*mod+B[i];\t}\tfor (int i=1;i&lt;=n;i++)\t\t{\t\t\tcin&gt;&gt;C[i];\t\t\tC[i]=C[i-1]*mod+C[i];\t\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(A[n]-A[i]*base[n-i])*base[i]+A[i];\t\tMP[cur]=i;//A左移动i位\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(B[n]-B[i]*base[n-i])*base[i]+B[i];//B左移动n位\t\tif (MP.count(C[n]-cur))\t\t\tans=min(ans,MP[C[n]-cur]+i);\t\t\t}\tcout&lt;&lt;((ans==mod)?-1:ans)&lt;&lt;endl;\treturn 0;}/*Test Data1:Test Data2:*/\n\n\n","categories":["算法竞赛"],"tags":["Hash","暴力","比赛"]},{"title":"React学习笔记(1) 类式组件相关","url":"/2022/03/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","content":"\n    待填坑\n\n\n    22.2.28 updated\n\n\n\n\n    prop-types\n\n\n    用于限定props的数据类型\n\n\nimport PropTypes from 'prop-types';class Greeting extends React.Component {  render() {    return (      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;    );  }}Greeting.propTypes = {  name: PropTypes.string};","categories":["大前端"],"tags":["Javascript","大前端","React"]},{"title":"Google Code Jam 2022-QR-T4-Chain Reactions","url":"/2022/04/03/gcj22ET4/","content":"\n    题面\n\n\nProblem\nWile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of N modules indexed 1,2,…,N. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called initiators. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a chain reaction.\nEach of the N modules has a fun factor Fi. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\nFor example, suppose Wile has 4 modules with fun factors F1=60,F2=20,F3=40, and F4=50 and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\nExample in statement when activating 4 then 3.\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of max(50,20,60)=60. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of 60+40=100.\nExample in statement when activating 3 then 4.\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of max(40,60)=60. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of max(50,20)=50, and an overall fun for the session of 60+50=110.\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.\nInputThe first line of the input gives the number of test cases, T. T test cases follow, each described using 3 lines. Each test case starts with a line with a single integer N, the number of modules Wile has. The second line contains N integers F1,F2,…,FN where Fi is the fun factor of the i-th module. The third line contains N integers P1,P2,…PN. If Pi=0, that means module i points at the abyss. Otherwise, module i points at module Pi.\nOutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum fun Wile can have by manually triggering the initiators in the best possible order.\nLimitsMemory limit: 1 GB.1≤T≤100.1≤Fi≤109.0≤Pi≤i−1, for all i.Test Set 1 (Visible Verdict)Time limit: 5 seconds.1≤N≤10.Test Set 2 (Visible Verdict)Time limit: 5 seconds.1≤N≤1000.Test Set 3 (Hidden Verdict)Time limit: 10 seconds.1≤N≤100000.SampleSample Inputsave_altcontent_copy3460 20 40 500 1 1 253 2 1 4 50 1 1 1 08100 100 100 90 80 100 90 1000 1 2 1 2 3 1 3Sample Outputsave_altcontent_copyCase #1: 110Case #2: 14Case #3: 490Sample Case #1 is the one explained in the problem statement.\nIn Sample Case #2, there are 4 initiators (modules 2 through 5), so there are 4 chain reactions. Activating them in order 3,5,4,2 yields chains of fun 3,5,4,2 for an overall fun of 14. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\nIn Sample Case #3, an optimal activation order of the 5 initiators is 4,5,7,6,8.\n\n\n\n    题目大意\n\n\n    给你一大坨点带权的森林。对于每棵树，每一次选择一个叶子结点一路走到根，对答案的贡献是这条路径上的最大值，并且走完之后路径上的点权就废了。可以知道改变选择叶子结点的顺序会得到不同的答案。现在求整个森林得到的最大答案是啥。\n\n\n\n    思路\n\n\n\n    写完三题过关就没看后面的，这两天补一下。\n\n\n\n    森林里每棵树是独立的。分治一下，如果是一个孤立的点，答案就是本身的权值。如果只有一个儿子，记一个结点的答案是f(i)，那么对于父亲u，答案就是max{val[u],f(i)}。\n\n\n\n    当有多个儿子的时候，其实就按照题面那个动态图的意思搞就行（谷歌用户体验牛逼，吹一把，题面都会动，太良心了）。其实这个时候就是针对所有儿子，选中的第一个就会把当前结点的值跑掉。我们已经dfs完了所有儿子，可以意会到，贪心地选择最小的一个答案，把它和val[u]比一下大小。如果比val[u]来得大，那么val[u]肯定对答案没有贡献。如果比val[u]小，那么相当于val[u]顶替掉最小的那份答案，而其他比之大的答案都应该直接贡献到最后的ans里。\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=100005;ll vis[N],val[N];vector&lt;ll&gt; G[N];ll n,ans,f;ll dfs(ll u,ll fa){    vis[u]=1;    vector&lt;ll&gt; dp;    ll sz=G[u].size();    for (ll i=0;i&lt;sz;i++)    {        ll v=G[u][i];        ll p=dfs(v,u);        dp.push_back(p);    }    sort(dp.begin(),dp.end());    if (sz==0)        return val[u];    for (ll i=1;i&lt;sz;i++)        ans+=dp[i];    return max(dp[0],val[u]);}int main(){    ll T;    cin&gt;&gt;T;    for (ll t=1;t&lt;=T;t++)    {        cin&gt;&gt;n;        for (ll i=1;i&lt;=n;i++)            cin&gt;&gt;val[i];        for (ll i=1;i&lt;=n;i++)            G[i].clear();        for (ll i=1;i&lt;=n;i++)        {            ll fa;            cin&gt;&gt;fa;            G[fa].push_back(i);        }        f=ans=0;        memset(vis,0,sizeof(vis));        for (ll i=1;i&lt;=n;i++)        {            if (!vis[i])                f+=dfs(i,-1);        }        ans=ans+f;        cout&lt;&lt;\"Case #\"&lt;&lt;t&lt;&lt;\": \";        cout&lt;&lt;ans&lt;&lt;endl;    }}","categories":["算法竞赛"],"tags":["比赛","Google Code Jam","贪心","分治"]},{"title":"React学习笔记(2) Hooks","url":"/2022/04/03/react2/","content":"\n    22.4.3 updated\n\n\n    关于hooks\n\n\n    React16.8的版本更新了Hooks功能。意味着函数式组件也可以拥有state属性。自此，类式组件基本完全可以被函数式组件替代。（除非要利用生命周期进行一些骚操作）。这也让利用React进行的开发更贴近\"函数式编程\"的潮流。\n\n\n\n  useState()\n\n\nfunction App() {  const [value,setValue]= useState(0);  return (      &lt;div&gt;         &lt;button onClick={()=&gt;{           setValue(value+1)         }}&gt;click to add 1&lt;/button&gt;        &lt;div&gt;           value={value}        &lt;/div&gt;      &lt;/div&gt;  );}//注意到如上代码使用了useState//[]中两个参数//第一个相当于class中state中的一个属性（变量），而第二个参数是一个方法（函数），用以改变这个属性的值。//useState()括号中为该属性的初始值//当我们需要改变value的值时，在class中this.setState({value:this.state.value+1})//而在hooks中直接setValue(value+1)//不要太方便，且省去了各种this来this去\n\n\n  不过来点面试题会发现其实看上去简单的东西也会有很多反直觉的坑。师哥给我丢了一道。\n\n\nfunction App() {    const [n, setN] = useState(0);     return (          &lt;div&gt;            &lt;h1&gt;{n}&lt;/h1&gt;            &lt;button onClick={() =&gt; setN(x =&gt; x + 1)}&gt;+1&lt;/button&gt;            &lt;button onClick={() =&gt; setTimeout(() =&gt; console.log(n), 3000)}&gt;log&lt;/button&gt;          &lt;/div&gt;        )}//先点log，然后立即点+1,3s后会打印出啥//答案是0//因为函数式组件在+1后进行了刷新，相当于重新执行了一下这个函数，并且创建了一个新的n//但是console.log中的n是通过闭包捕获的，函数第一次执行时的n,所以无论函数再怎么被翻江倒海//打印出的值始终是第一次的n\n\n\n    useEffect()\n","categories":["大前端"],"tags":["Javascript","大前端","React"]},{"title":"Codeforces 1660F Promising String (hard version) 找规律+前缀和","url":"/2022/04/05/cf1660F/","content":"\n    题面\n\n\n\nF2. Promising String (hard version)\ntime limit per test2 seconds\nmemory limit per test256 megabytes\ninputstandard input\noutputstandard output\nThis is the hard version of Problem F. The only difference between the easy version and the hard version is the constraints.\n\nWe will call a non-empty string balanced if it contains the same number of plus and minus signs. For example: strings “+–+” and “++-+–” are balanced, and strings “+–”, “–” and “” are not balanced.\nWe will call a string promising if the string can be made balanced by several (possibly zero) uses of the following operation:\nreplace two adjacent minus signs with one plus sign.In particular, every balanced string is promising. However, the converse is not true: not every promising string is balanced.\nFor example, the string “-+—“ is promising, because you can replace two adjacent minuses with plus and get a balanced string “-++-“, or get another balanced string “-+-+”.\nHow many non-empty substrings of the given string 𝑠 are promising? Each non-empty promising substring must be counted in the answer as many times as it occurs in string 𝑠.\nRecall that a substring is a sequence of consecutive characters of the string. For example, for string “+-+” its substring are: “+-“, “-+”, “+”, “+-+” (the string is a substring of itself) and some others. But the following strings are not its substring: “–”, “++”, “-++”.\nInputThe first line of the input contains an integer 𝑡 (1≤𝑡≤104) —the number of test cases in the test.\nThen the descriptions of test cases follow.\nEach test case of input data consists of two lines. The first line consists of the number 𝑛 (1≤𝑛≤2⋅105): the length of 𝑠.\nThe second line of the test case contains the string 𝑠 of length 𝑛, consisting only of characters “+” and “-“.\nIt is guaranteed that the sum of values 𝑛 over all test cases does not exceed 2⋅105.\nOutputFor each test case, print a single number: the number of the promising non-empty substrings of string 𝑠. Each non-empty promising substring must be counted in the answer as many times as it occurs in string 𝑠.\nExampleinputCopy53+-+5-+—4\n\n7–+—+6+++—outputCopy24274NoteThe following are the promising substrings for the first three test cases in the example:\n𝑠[1…2]=”+-“, 𝑠[2…3]=”-+”;𝑠[1…2]=”-+”, 𝑠[2…3]=”+-“, 𝑠[1…5]=”-+—“, 𝑠[3…5]=”—“;𝑠[1…3]=”—“, 𝑠[2…4]=”—“.\n\n\n\n    题目大意\n\n\n    给你一个长度为n，只包含+-符号的字符串。连续两个-可以合并成一个+。问你该字符串中有多少子串满足，经过一些合并（或没有合并）后子串中+-号数量相等。\n\n\n\n    题解\n\n\n\n    \n        上结论：\n    \n    子串中-的个数比+多，且差值是3的倍数，则记一次贡献。\n\n\n\n    首先根据狄利克雷原理（抽屉原理），如果-的个数比+多于2个即一定有两个-相连。并且进行一次操作后，+-号的差异度会+3。那么就可以进行很多次操作将差异度变为0。\n\n\n\n    这题有小数据，那么对于小数据，O(n^2)的暴力为（假设一开始差异度为n）。\n\n\ncur=n;for (int i=0;i&lt;n;i++){    cur+=(s[i]=='+')?1:-1;    dp[i]=cur;    for (int j=0;j&lt;i;j++)        if (s[j]&gt;s[i] &amp;&amp; (s[j]-s[i])%3==0)            ans++;//[j,i]为合理区间}\n\n\n    考虑优化这个的暴力，如果把cur模3 ，那么当前右端点的贡献就是左侧所有比它大的%3剩余系的值。看到很多人写了一个log级的数据结构，但观察到差异度最大值为2n-1，不是很大，所以直接可以开个表记录一下，O(n)查询。\n\n\ninline void solve(){\tint n;\tcin&gt;&gt;n;\tstring s;\tcin&gt;&gt;s;\tint lim=2*n+1;\tint lst=n;\tvector&lt;int&gt; f (3,0);\tvector&lt;int&gt; cnt (lim,0);\tf[lst%3]++;\tcnt[lst]++;\tll ans=0;\tfor (int i=0;i&lt;n;i++)\t{\t\tint cur=lst;\t\tif (s[i]=='+')\t\t{\t\t\tf[cur%3]-=cnt[cur];//比cur小的不能用了\t\t\tcur++;\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\telse{\t\t\tcur--;\t\t\tf[cur%3]+=cnt[cur];//小于等于cur的都能用\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\tlst=cur;\t}\tcout&lt;&lt;ans&lt;&lt;endl;}\n","categories":["算法竞赛"],"tags":["Codeforces","前缀和","字符串","找规律"]}]