[{"title":"浙工大校赛-puzzle-Hash","url":"/2022/03/22/22-3-puzzle/","content":"\n题目大意\n\n    给三个长度为n(1&lt;=n&lt;=100 000)的数组A,B,C。可以将A数组或者B数组左移，每次移动记一次操作，问最少多少次操作可以使得Ai+Bi=Ci，否则扣-1。\n\n题解\n\n 比赛的时候脑子抽了...推了一个非充要条件，然后看有点假，想想会不会是字符串相关的题，然后去做核酸了。\n\n\n    后来发现很假，直接环形哈希就完事儿了。带上map复杂度是的。\n\n//This amazing code is written by Primo.Jay.Pan From CUC//Any questions please contact me//QQ:898021802//Mail: primojpan@gmail.com//.    primojaypan@cuc.edu.cn// Untitled 3.txt// Created by Primo Jay Pan on 2022/3/22.//While (true) RP++;//head#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;csignal&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int,int&gt;#define pll pair&lt;ll,ll&gt;#define INF 0x3f3f3f3f#define maxlongint 2147483647#define maxint 32767#define pi(double)acos(-1.0)#define eps 1e-9#define MID ((l+r)&gt;&gt;1)#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)//clear the array#define cla(a) memset(a,0,sizeof(a))#define clb(a) memset(a,INF,sizeof(a))#define clc(a) memset(a,-1,sizeof(a))using namespace std;const ull mod=998244353;const int maxn =100010; ull A[maxn],B[maxn],C[maxn],base[maxn];map&lt;ull , int &gt; MP;int n;inline void init(){\tbase[0]=1;\tfor (int i=1;i&lt;=n;i++)\t\tbase[i]=base[i-1]*mod;\t}int ans=mod;//mainint main(){\t//freopen(\"Untitled 3.txt.in\",\"r\",stdin);\t//freopen(\"Untitled 3.txt.out\",\"w\",stdout);\tcin&gt;&gt;n;\tinit();\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;A[i];\t\tA[i]=A[i-1]*mod+A[i];\t}\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;B[i];\t\tB[i]=B[i-1]*mod+B[i];\t}\tfor (int i=1;i&lt;=n;i++)\t\t{\t\t\tcin&gt;&gt;C[i];\t\t\tC[i]=C[i-1]*mod+C[i];\t\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(A[n]-A[i]*base[n-i])*base[i]+A[i];\t\tMP[cur]=i;//A左移动i位\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(B[n]-B[i]*base[n-i])*base[i]+B[i];//B左移动n位\t\tif (MP.count(C[n]-cur))\t\t\tans=min(ans,MP[C[n]-cur]+i);\t\t\t}\tcout&lt;&lt;((ans==mod)?-1:ans)&lt;&lt;endl;\treturn 0;}/*Test Data1:Test Data2:*/\n\n\n","categories":["算法竞赛"],"tags":["Hash","暴力","比赛"]},{"title":"CUC-Spring-Traning-Contest题解","url":"/2022/05/18/CUC-Spring-Traning-Contest%E9%A2%98%E8%A7%A3/","content":"D - Yet Another Palindrome Partitioning\n\n\n    【题目大意】\n\n\n给你一坨字符串，现在你可以分割它，问你最少分割成多少个子串可以使每个子串重新排列后能成为一个回文串。\n\n\n    【题解】\n\n\n观察一下回文串的性质，长度为偶数的回文串中所有字母的出现次数必定是偶数，而长度为奇数的回文串是在长度为偶数的回文串的基础上加一个出现次数为奇数的字母。\n\n\n所以我们用一个26位的二进制数表示读入到当前这个位置的字母时每个字母出现的次数的奇偶性，如果当前这个状态某字母出现次数是奇数则该位为奇数。然后我们枚举出现次数为奇数的那个字母，如果当前状态的该位和这个字母的奇偶性不一样那么就可以转移了。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 200010const int maxm=1&lt;&lt;26;#define INF 0x3f3f3f3fint dp[maxm];char s[maxn];int idx(char x){\tint ans=x-'a';\treturn 1&lt;&lt;ans;}int main(){\tmemset(dp,INF,sizeof(dp));\tcin&gt;&gt;s;\tint n=strlen(s);\tdp[0]=0;\tint now=idx(s[0]);\tdp[now]=1;\tfor (int i=1;i&lt;n;i++)\t{\t\tnow^=idx(s[i]);\t\tfor (int j=0;j&lt;=25;j++)\t\t{\t\t\tif (now^(1&lt;&lt;j)!=now) dp[now]=min(dp[now],dp[now^(1&lt;&lt;j)]+1);\t\t}\t}\tif (now==0) dp[now]=1;\tprintf(\"%d\\n\",dp[now]);\treturn 0;}\n\n\nE - Martian Strings\n\n\n    【题目大意】\n\n\n给你一个文本串T,对于每个询问串问你是不是可以将T拆成两个连续子串拼成每个询问串.\n\n\n    【题解】\n\n\nz algorithm可以线性地搞出来一个字符串的每个后缀和它自身的最长公共前缀.\n\n我们把每个询问串s搞成s的形式跑一遍再把和倒过来搞一个T’再跑一遍z algorithm,然后在第一个T的z数组里跑对于每个能匹配一部分的点看它在T’中对应的点的前面是否能拼成这个串..(非常抽象..看代码…)\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005#define maxm 1005#define ll long longll ans=0;char S[maxn],S2[maxn],s[maxn+maxm],t[maxn+maxm];char t1[maxm],t2[maxm];int z1[maxn+maxm],z2[maxn+maxm];inline void getz(int *z,int sz){\t\tz[0]=sz;\t\tint j=1,k;\t\tfor (int i=1;i&lt;sz;i=k)\t\t{\t\t\tif (j&lt;i) j=i;\t\t\twhile (s[j-i]==s[j] &amp;&amp; j&lt;sz) j++;\t\t\tz[i]=j-i;\t\t\tk=i+1;\t\t\twhile (k+z[k-i]&lt;j) k++;\t\t}}int main(){\tcin&gt;&gt;S;\tint N=strlen(S);\tfor (int j=0,cnt=N-1;cnt&gt;=0;j++,cnt--) S2[j]=S[cnt];\tint T;\tcin&gt;&gt;T;\twhile (T--)\t{\t\tmemset(z1,0,sizeof(z1));memset(z2,0,sizeof(z2));\t\tcin&gt;&gt;t1;\t\tint M=strlen(t1);\t\tif (M&lt;2 || M&gt;N) continue;\t\tfor (int j=0,cnt=M-1;cnt&gt;=0;j++,cnt--) t2[j]=t1[cnt];\t\tfor (int i=0;i&lt;M;i++) s[i]=t1[i];\t\ts[M]='$';\t\tfor (int i=M+1,j=0;j&lt;N;j++,i++) s[i]=S[j];\t\tgetz(z1,N+M+1);\t\tfor (int i=0;i&lt;M;i++) s[i]=t2[i];\t\ts[M]='$';\t\tfor (int i=M+1,j=0;j&lt;N;j++,i++) s[i]=S2[j];\t\tgetz(z2,N+M+1);\t\tfor (int i=1;i&lt;=N;i++) z1[i]=z1[i+M];\t\tfor (int i=1;i&lt;=N;i++) z2[i]=z2[i+M];\t\tz2[0]=0;\t\tfor (int i=1;i&lt;=N;i++) z2[i]=max(z2[i],z2[i-1]);\t\tfor (int i=1;i&lt;=N;i++){\t\t\tif (z1[i]!=0) {int pos=z1[i]+i-1+(M-z1[i]);\t\t\t\tpos=N-pos+1;\t\t\t\tif (pos&lt;1 || pos&gt;N) continue;\t\t\t\tif (z2[pos]+z1[i]&gt;=M) {ans++;break;}\t}}}\tcout&lt;&lt;ans&lt;&lt;endl;}\n\n\nF - Promising String (hard version) \n\n\n\n    题目大意\n\n\n    给你一个长度为n，只包含+-符号的字符串。连续两个-可以合并成一个+。问你该字符串中有多少子串满足，经过一些合并（或没有合并）后子串中+-号数量相等。\n\n\n\n    题解\n\n\n\n    \n        上结论：\n    \n    子串中-的个数比+多，且差值是3的倍数，则记一次贡献。\n\n\n\n    首先根据狄利克雷原理（抽屉原理），如果-的个数比+多于2个即一定有两个-相连。并且进行一次操作后，+-号的差异度会+3。那么就可以进行很多次操作将差异度变为0。\n\n\n\n    这题有小数据，那么对于小数据，O(n^2)的暴力为（假设一开始差异度为n）。\n\n\ncur=n;for (int i=0;i&lt;n;i++){    cur+=(s[i]=='+')?1:-1;    dp[i]=cur;    for (int j=0;j&lt;i;j++)        if (s[j]&gt;s[i] &amp;&amp; (s[j]-s[i])%3==0)            ans++;//[j,i]为合理区间}\n\n\n    考虑优化这个的暴力，如果把cur模3 ，那么当前右端点的贡献就是左侧所有比它大的%3剩余系的值。看到很多人写了一个log级的数据结构，但观察到差异度最大值为2n-1，不是很大，所以直接可以开个表记录一下，O(n)查询。\n\n\ninline void solve(){\tint n;\tcin&gt;&gt;n;\tstring s;\tcin&gt;&gt;s;\tint lim=2*n+1;\tint lst=n;\tvector&lt;int&gt; f (3,0);\tvector&lt;int&gt; cnt (lim,0);\tf[lst%3]++;\tcnt[lst]++;\tll ans=0;\tfor (int i=0;i&lt;n;i++)\t{\t\tint cur=lst;\t\tif (s[i]=='+')\t\t{\t\t\tf[cur%3]-=cnt[cur];//比cur小的不能用了\t\t\tcur++;\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\telse{\t\t\tcur--;\t\t\tf[cur%3]+=cnt[cur];//小于等于cur的都能用\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\tlst=cur;\t}\tcout&lt;&lt;ans&lt;&lt;endl;}\n\n\nG - Jumping on Walls \n\n\n暴力DFS即可…\n#include&lt;stdio.h&gt;  #include&lt;string.h&gt;  #include&lt;math.h&gt;  #include&lt;stdlib.h&gt;  #include&lt;queue&gt;  #include&lt;vector&gt;  #include &lt;bits/stdc++.h&gt;  using namespace std;  const int maxn=1e5+100;  int n,m,water;  char a[2][maxn];  int v[2][maxn];  int dfs(int pos,int j){      if(j&gt;n) return 1;      if(a[pos][j]=='X'||j&lt;water||v[pos][j]) return 0;      v[pos][j]=1;      water++;      int f=dfs(pos,j-1)||dfs(1-pos,j+m)||dfs(pos,j+1);      water--;      return f;  }  int main(){        scanf(\"%d %d\",&amp;n,&amp;m);          water=1;          scanf(\"%s %s\",a[0]+1,a[1]+1);          if(dfs(0,1)) printf(\"YES\\n\");          else printf(\"NO\\n\");      return 0;  }  ","categories":["算法竞赛"],"tags":["算法竞赛"]},{"title":"HarmonyHeaven前期论文阅读","url":"/2023/09/07/HarmonyHeaven%E5%89%8D%E6%9C%9F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","content":"\n    HarmonyHeaven是为学龄前或小学前期阶段自闭症儿童提供的一套智能音乐治疗/教学系统。它需要一名经过训练的治疗师与自闭症儿童共同完成音乐创作。\n通过对中国儿歌的大量曲调分析，我们发现能给儿童带来积极情绪的主要是由最简单的三和声系统组成。在治疗过程中，咨询师会改变自己的肢体动作来改变当前的和声色彩；而孩子则可以在一块纤维投影屏幕前，在探索屏幕粒子系统变化的同时，根据导师的指导创作出音符（系统会使得音符落在和声学范围内，使生成的音乐不至于不悦耳）。\n即兴音乐疗法已被广泛证明有助于自闭症儿童的社交、交流和行为能力，我们的系统也会嵌入中国当前基础音乐教学比较薄弱的一环：和声学，让特殊群体儿童也能从情绪层面上对音乐是如何创作的产生一个基本概念，激发他们对音乐的兴趣，促进他们更好地融入社会。\n\n\n    Q1.自闭症儿童为何需要学习音乐创作，对他们有何好处？普遍来讲社交是自闭症患者的最大问题。\n    \n    Q2.音乐治疗里的音乐是否有什么共性，这样素材目前是来自于哪里？在治疗中一般如何使用？为何需要让老师和孩子共创音乐\n\n\n\n\n\n    Music Interventions for Children with Autism: Narrative Review of the Literature\n    (Kate Simpson et al.)\n\n\n\n\n    摘要：实验从128篇相关领域论文中选择了一部分进行深入研究。事先编好的歌曲与即兴创作歌曲的相关疗法都包含其中。实验均有证据表面音乐疗法有助于促进自闭症儿童的社交、交流能力和行为能力。\n\n\n\n    \n        The nonverbal aspect of music\n        is viewed as a means of engaging the child and the therpist/others in musical-emotional communcation.\n    \n\n\n音乐的非言语性会增加孩子与治疗师在音乐情感上的交流。\n\n\n\n\n    \n        Improvisational music therapy and the use \nof composed songs were the predominant forms of music interventions reported in the reviewed studies.\n    \n\n\n    \n        Both techniques demonstrated some support for the use of music to facilitate target skills in the areas of communication and socialization. One found that improvisational music therapy was more effective than set songs in facilitating change in targeted skills.\n\n\n\n\n\n    使用即兴音乐疗法和事先编好的音乐进行音乐治疗是\n研究中使用的主流方法。他们都能促进交流与社交技巧。一个实验发现即兴音乐治疗比预制音乐比固定音乐更为行之有效。\n\n\n\n\n\n    The Effects of Improvisational Music Therapy on Joint Attention Behaviors in Autistic Children: A Randomized Controlled Study\n    (Jinah Kim et al.)\n\n\n\n   摘要：该实验建立了两个对照组，一组让学龄前自闭症儿童在\n    治疗师的指导下使用乐器作即兴创作；另一组在治疗师的指导下玩各种各样的玩具以及完成指令。\n    实验采用一些列对教学视频的定量分析，如观察患儿与治疗师的eye contact以及让咨询师和家长分别填写PDDBI专业量表进行了定量分析。得出结论即兴音乐治疗可以更好地促进自闭症儿童地专注行为能力以及非言语性社交技巧。\n","tags":["科研论文"]},{"title":"Javascript在宿主软件中演奏软件乐器","url":"/2022/03/18/Javascript%E5%9C%A8%E5%AE%BF%E4%B8%BB%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%BC%94%E5%A5%8F%E8%BD%AF%E4%BB%B6%E4%B9%90%E5%99%A8/","content":"JS与Logic Pro X这样的编曲宿主软件实现通信，听起来就是一个很酷的功能，这意味着你编曲时使用的MIDI信号完全可以由代码生成。尤其是有了p5和tf.js之类的前端库，在人机交互时可以将交互时产生的信号映射成MIDI信号生成音乐。\nWebMidi库就是一个可以实现JS与MIDI设备通信的Javascript库。相当于在浏览器和MIDI设备之间架起了一座桥梁。我们通过Macbook系统自带的虚拟MIDI设备IAC Driver可以直接与编曲软件Logic Pro进行通信。\n 在 启动台-其他中找到音频MIDI设置\n\nCommand+2打开MIDI工作室窗口，选定Bus 1端口，Apply！\n\n然后打开Logic，新建软件乐器轨道，这个时候我们通过JS写的代码就可以通过虚拟MIDI导入到Logic中了\n接下来编写代码，因为WebMidi基于http协议，我们需要把一个html文件挂到本地服务器上，然后引入WebMidi库，CDN或本地化后皆可，我这里将WebMidi本地化了\n\n\n&lt;script src=\"webmidi.iife.js\"&gt;&lt;/script&gt;\n\n然后为WebMidi的初始化绑定一个事件，初始化函数如下\n\nfunction init(){    WebMidi.enable(err=&gt;    {        if (err) console.log(err);        WebMidi.outputs.forEach(output=&gt;{          if (output.name===\"IAC Driver Bus 1\")            window.output=output        })      },true)      startLoop()//开始循环}\n注意output.name要选定你的虚拟MIDI端口，然后在startLoop中我们就可以编写MIDI数据了\n我们演奏一个音需要用到output.playNote()方法，该函数有三个参数，第一个是音高（Note），你可以选择0～127之间任意一个整数，也可以直接以字符串的形式比如\"C#4\"来代表这个音，或者传入一个Note对象。第二个参数是轨道参数，记得在Logic中配置每个乐器的轨道名。第三个参数是一个对象，对象中可以修改time,attack,duration,release等参数，和我们混音时这些参数所代表的含义基本一致。\n下面是我第一次写的曲子，苏联时期新闻联播的主题曲《Forward Time》的一个小片段，制谱参考油管视频G. Sviridov - Time, Forward! | Piano Tutorial (100,000 special)。做了一个小demo，写到了副歌，感觉效果还行。有了这个基础，去制作更有意思的与音乐有关的前端交互作品便成了可能。\n\nfunction startLoop()    {      var step=1;      var step2=1;      setInterval(()=&gt;{        if (step2/16&lt;12) {          if (step === 1 || step === 9)            output.playNote(\"E2\", 1, {duration: 200, attack: 0.8})          if (step === 3 || step === 11)            output.playNote(\"G2\", 1, {duration: 200, attack: 0.8})          if (step === 5 || step === 13)            output.playNote(\"A#2\", 1, {duration: 200, attack: 0.8})          if (step === 7 || step === 15)            output.playNote(\"C#3\", 1, {duration: 200, attack: 0.8})        }        if ((step2/16&gt;=4 &amp;&amp; step2/16&lt;5)||(step2/16&gt;=6 &amp;&amp; step2/16&lt;7))        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:1100,attack:0.9})            output.playNote(\"A#3\",2,{duration:1100,attack:0.9})            output.playNote(\"C#3\",2,{duration:1100,attack:0.9})          }        }        if (step2/16&gt;=8 &amp;&amp; step2/16&lt;9)        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=9 &amp;&amp; step2/16&lt;11)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=11 &amp;&amp; step2/16&lt;12)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=12 &amp;&amp; step2/16&lt;18)        {          if (step%2===1)          {            output.playNote(\"F#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})            output.playNote(\"C#4\",1,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=14 &amp;&amp; step2/16&lt;15)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=15 &amp;&amp; step2/16&lt;16)        {          if (step===1) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1)          {            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=17 &amp;&amp; step2/16&lt;18)        {          if (step===1) {            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 300, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 300, attack: 0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;20)        {          if (step%2===1)          {            output.playNote(\"A#2\",1,{duration:100,attack:0.9})            output.playNote(\"D#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;19)        {          if (step===1){          output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"F#6\", 2, {duration: 1500, attack: 0.9})        }}        if (step2/16&gt;=19 &amp;&amp; step2/16&lt;20)        {          if (step===1){            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }          if (step===9){            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=20 &amp;&amp; step2/16&lt;21)        {          if (step===1){            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"G#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }}        if (step2/16&gt;=20 )        {          if (step%2===1)          {            output.playNote(\"C#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})          }        }step++;        if (step&gt;16)step=1;        step2++;       // step2++;        //if (step2&gt;32) step2=1      },100)    }","categories":["大前端"],"tags":["前端","Javascript","音乐","编曲"]},{"title":"Pose-Detection-in-Web","url":"/2022/05/18/Pose-Detection-in-Web/","content":"Pose-Detection Demos in WebAuthor : Primo\nThis package involves some demos I collected that using state-of-the-art models for running real-time pose detectionin your browser.\nHint: Since most of models in the package are trained by Google,make sure that you are able to bypass the GFW.\nBefore we start, let’s give a brief introduction to the principle of pose-detection technology in web browsers.\nAbove all, every ingenious effect achievement in this package is realized by machine learning.In brief, machine learning is a method that you make the computer understand something by teaching it something.You tell the computer that ‘A’ is ‘A’ and “B” isn’t ‘A’ many many many times by delivering countless data to the computer,and we call it ‘Dataset’.Then the computer will learn the Dataset via some algorithms.After the learning process, if you give the computer some information,it will classify them.And then it can tell you “A” is  “A’ with a great probability.\n\n\n\n\nThese days, we have many platforms to  create machine learning models.Tensorflow(Google) and Pytorch(Facebook/Meta) are popular ones among them.Both of them require Python skills to create and apply models.To Digital Art Designers/Game Developers/Software Engineers(especially Front-End Engineers) who do not have enough mathematic and Python-Programming skills,nevertheless,those platforms have steep learning curve.\nTo make machine-learning skills easier for developers,Google released a Javascript library Tensorflow.js.It makes it possible for us to create machine learning models in Javascript or in another word,in Web.Meanwhile,Node.JS is also available.Since web is so convenient that we can use it on almost every console.And we can ‘Code once,run everywhere’.\nTo simplify the process further,we got ML5.JS.It is derived from tensorflow.js and relies heavily on P5.JS which is another JS library (processing in the web).So you can consider that both ML5.JS and P5.JS are designed for we digital-art students or someone(newbie) who is interested in the application of AI.\n01-Posenet in P5.jsTensorflow.js provides 3 kinds of pose-detection models:MoveNet, Blazepose and Posenet.They’re trained by different research teams in Google.In ML5.js, we use the Posenet model.\nPosenet is trained by the dataset “COCO”((Microsoft Common Objects in Context)).It is a large-scale object detection, segmentation, key-point detection, and captioning dataset. The dataset consists of 328K images.\nAs a result ,in Posenet ,we got a keypoint diagram called COCO Keypoints,and so does it in Movenet.\n\n    \n\n\nThe data will be reserved in an array, and their index are:\n0: nose1: left_eye2: right_eye3: left_ear4: right_ear5: left_shoulder6: right_shoulder7: left_elbow8: right_elbow9: left_wrist10: right_wrist11: left_hip12: right_hip13: left_knee14: right_knee15: left_ankle16: right_ankle\n\nIn ML5.JS,once we detect a “pose” from the image or video, we got an object.First, it has a score stands for the confidence score.Then we got an array called “keypoints”.The 17 points are reserved in the order above in this array,and every point has a score,’part’ and a position coordinate.For the coordinate,x and y represent the actual keypoint position in the image,which is different from that in Blazepose.Besides the array,each part is stored in the object,so if you want to know the x index of “nose”,just use let x=pose.nose.x.\n{    \"score\": 0.36062840477782576,    \"keypoints\": [        {            \"score\": 0.9998100399971008,            \"part\": \"nose\",            \"position\": {                \"x\": 304.9208122283104,                \"y\": 309.5389037373465            }        },        {            \"score\": 0.9993601441383362,            \"part\": \"leftEye\",            \"position\": {                \"x\": 350.35096105434553,                \"y\": 267.1330611529517            }        },        {            \"score\": 0.9985820055007935,            \"part\": \"rightEye\",            \"position\": {                \"x\": 278.3887003367977,                \"y\": 259.3134281143604            }        },        {            \"score\": 0.8186571002006531,            \"part\": \"leftEar\",            \"position\": {                \"x\": 397.34817979864573,                \"y\": 290.57919038408926            }        },        {            \"score\": 0.4284822642803192,            \"part\": \"rightEar\",            \"position\": {                \"x\": 235.44428754873314,                \"y\": 282.58995798311344            }        },        {            \"score\": 0.8433191776275635,            \"part\": \"leftShoulder\",            \"position\": {                \"x\": 471.59480588445405,                \"y\": 496.9624085185129            }        },        {            \"score\": 0.9728891253471375,            \"part\": \"rightShoulder\",            \"position\": {                \"x\": 154.78833803406948,                \"y\": 479.0577168594539            }        },        {            \"score\": 0.0226301196962595,            \"part\": \"leftElbow\",            \"position\": {                \"x\": 529.4033742229299,                \"y\": 585.576703854572            }        },        {            \"score\": 0.017581390216946602,            \"part\": \"rightElbow\",            \"position\": {                \"x\": 34.78550595532132,                \"y\": 580.9919186603234            }        },        {            \"score\": 0.0062744165770709515,            \"part\": \"leftWrist\",            \"position\": {                \"x\": 512.406827577821,                \"y\": 553.6286341448239            }        },        {            \"score\": 0.002704796614125371,            \"part\": \"rightWrist\",            \"position\": {                \"x\": 76.06921570774182,                \"y\": 557.3660603293185            }        },        {            \"score\": 0.00424220459535718,            \"part\": \"leftHip\",            \"position\": {                \"x\": 398.1407143077034,                \"y\": 564.717056927514            }        },        {            \"score\": 0.00541426008567214,            \"part\": \"rightHip\",            \"position\": {                \"x\": 240.92917965543873,                \"y\": 555.8058724607475            }        },        {            \"score\": 0.0022254108916968107,            \"part\": \"leftKnee\",            \"position\": {                \"x\": 400.528016146055,                \"y\": 551.4891182866078            }        },        {            \"score\": 0.0033826844301074743,            \"part\": \"rightKnee\",            \"position\": {                \"x\": 184.80833773483099,                \"y\": 543.0382065828672            }        },        {            \"score\": 0.002814995124936104,            \"part\": \"leftAnkle\",            \"position\": {                \"x\": 386.2246680352475,                \"y\": 550.1599762319127            }        },        {            \"score\": 0.002312745898962021,            \"part\": \"rightAnkle\",            \"position\": {                \"x\": 152.1527099609375,                \"y\": 543.721379974009            }        }    ],    \"nose\": {        \"x\": 304.9208122283104,        \"y\": 309.5389037373465,        \"confidence\": 0.9998100399971008    },    \"leftEye\": {        \"x\": 350.35096105434553,        \"y\": 267.1330611529517,        \"confidence\": 0.9993601441383362    },    \"rightEye\": {        \"x\": 278.3887003367977,        \"y\": 259.3134281143604,        \"confidence\": 0.9985820055007935    },    \"leftEar\": {        \"x\": 397.34817979864573,        \"y\": 290.57919038408926,        \"confidence\": 0.8186571002006531    },    \"rightEar\": {        \"x\": 235.44428754873314,        \"y\": 282.58995798311344,        \"confidence\": 0.4284822642803192    },    \"leftShoulder\": {        \"x\": 471.59480588445405,        \"y\": 496.9624085185129,        \"confidence\": 0.8433191776275635    },    \"rightShoulder\": {        \"x\": 154.78833803406948,        \"y\": 479.0577168594539,        \"confidence\": 0.9728891253471375    },    \"leftElbow\": {        \"x\": 529.4033742229299,        \"y\": 585.576703854572,        \"confidence\": 0.0226301196962595    },    \"rightElbow\": {        \"x\": 34.78550595532132,        \"y\": 580.9919186603234,        \"confidence\": 0.017581390216946602    },    \"leftWrist\": {        \"x\": 512.406827577821,        \"y\": 553.6286341448239,        \"confidence\": 0.0062744165770709515    },    \"rightWrist\": {        \"x\": 76.06921570774182,        \"y\": 557.3660603293185,        \"confidence\": 0.002704796614125371    },    \"leftHip\": {        \"x\": 398.1407143077034,        \"y\": 564.717056927514,        \"confidence\": 0.00424220459535718    },    \"rightHip\": {        \"x\": 240.92917965543873,        \"y\": 555.8058724607475,        \"confidence\": 0.00541426008567214    },    \"leftKnee\": {        \"x\": 400.528016146055,        \"y\": 551.4891182866078,        \"confidence\": 0.0022254108916968107    },    \"rightKnee\": {        \"x\": 184.80833773483099,        \"y\": 543.0382065828672,        \"confidence\": 0.0033826844301074743    },    \"leftAnkle\": {        \"x\": 386.2246680352475,        \"y\": 550.1599762319127,        \"confidence\": 0.002814995124936104    },    \"rightAnkle\": {        \"x\": 152.1527099609375,        \"y\": 543.721379974009,        \"confidence\": 0.002312745898962021    }}\n\n02-Handpose in P5.js\n    \n\nHandpose is a machine-learning model that allows for palm detection and hand-skeleton finger tracking in the browser. It can detect a maximum of one hand at a time and provides 21 3D hand keypoints that describe important locations on the palm and fingers.\n\n    \n\n\nJust like  Posenet ,we will get an object from the server after detecting the hand.Firstly,the model has an array which stores the coordinate of 21 keypoints of hand above in order.Pay attention that every coordinate has three values [x,y,z]. [x,y] stands for the location of the point in the 2-D plane, and z is the number of z-index means you can use it in the 3-D space.\nBesides the array we have an object in the object called ‘annotations’.It stores every finger’s information.So if you want query the information of ‘thumb’,let thumb=object.annotations.thumb\n{    \"thumb\": [        [            311.1474129357343,            392.8839134580602,            31.628944396972656        ],        [            305.308736143059,            365.20717624808134,            40.958133697509766        ],        [            296.55928350326406,            344.6487949195921,            42.178436279296875        ],        [            289.09028835985714,            321.9771320066599,            41.17280578613281        ]    ],    \"indexFinger\": [        [            351.26226986601506,            315.317770126479,            33.45431900024414        ],        [            317.7573958881063,            287.82946656887157,            41.258514404296875        ],        [            301.0551201111043,            279.13742066547405,            45.38811111450195        ],        [            295.82737357654224,            276.7010123385984,            46.33940887451172        ]    ],    \"middleFinger\": [        [            353.7122101313199,            309.04347842173087,            16.16316032409668        ],        [            294.2536349253059,            291.90549768414684,            24.071781158447266        ],        [            277.4029452280277,            312.1420227467726,            23.412212371826172        ],        [            282.40719597599997,            328.68568506297936,            20.75050163269043        ]    ],    \"ringFinger\": [        [            343.6278986695346,            307.76669737200876,            1.2318196296691895        ],        [            281.3661445784785,            301.97755074942916,            9.658766746520996        ],        [            269.26558032780065,            333.03373573840565,            8.836081504821777        ],        [            278.37322912437753,            350.7239374751061,            4.151844024658203        ]    ],    \"pinky\": [        [            327.2987480246994,            307.3400266338206,            -11.768608093261719        ],        [            281.79613233056017,            306.4856480945225,            -2.7679641246795654        ],        [            274.7228580919318,            333.18432280186977,            -1.2925504446029663        ],        [            287.3491935974832,            347.7520597512496,            -4.416280746459961        ]    ],    \"palmBase\": [        [            333.42525789734873,            414.1195342209028,            -0.0014080926775932312        ]    ]}\n\n03-Handpose+Posenet in P5.js\n\n\n\nNow we can combine the two models together.So we can get both pose data and one hand’s data.With this data, we can make some simple classifications.The demo written by me can recognize which hand is detecting,by comparing the distance of palm(Handpose) and Wrist(Posenet).\nAnd, we can make use of the coordinate of every finger to judge if it is bent.If it is bent,the circle of this finger in the image will turn red.We are able to recognize some gestures like ‘1,2,3,4,5,6’ via counting which finger is bent,without machine learning algorithms.\n04-train_own_modelDespite computing coordinates by their positional relationship,you can also use machine learning skills to classify a gesture.\nIn ml5.js,it’s not very difficult for us to train our own models.\nI’ve written a demo in 04-train-own_model.\nThe model can train 4 different gestures.If you want to train more models,find all the ‘options’ in all javascript documents and change the ‘output’ number to whatever you want.\nFirst,open the ‘collect’ document.Press any button on your keyboard except ‘s’.And then you will see the ‘waiting’ on the screen turns to ‘ready’.You need to get ready to show your gestures in front your webcams.Then ‘ready’ will turn to ‘collecting’.The program starts to collect your body’s data.\nThen the word will trun to ‘waiting’ again,you are able to press another key.After you’ve pressed 4 keys (or the number you want),press ‘S’ and you will get a JSON document that stores the data.\nRename the JSON file and drag it to the file ‘train’.\nChange your root to ‘train’ , open the ‘index.js’.In line 12,change the json file’s name to what you’ve just renamed it.And then run the HTML file.The model will be training.\n\n\n\n\nWait a minute,and you will get three files.\nChange your root to “classify” folder.And put those files in the folder “model”.\nRun the HTML file, and make some poses.The computer is able to classify the pose by models your trained!\n05-Blazepose_P5.jsBlazepose is another model released by a Google research team Mediapipe.You can use it in both tensorflow.js or mediapipe environment.\nBlazepose is the Superset of COCO,BlazeFace and BlazePalm.MediaPipe BlazePose can detect 33 keypoints, in addition to the 17 COCO keypoints, it provides additional keypoints for face, hands and feet.\n\n\n\n\nEach of the object of the 33-long array contains four variables.[x,y,z] stands for real-world 3D coordinates in meters with the origin at the center between hips.Unlike Posenet’s Data,the coordinate numbersin Blazepose have been normalized.So it’s always between [0,1].Once you want to transfer it on your screen,you have to multiply it to the height and width of the canvas.And another variables which name ‘visibility’stands for the confidence score.\nTough Blazepose can detect only one person,it’s much more steady than Posenet from my point of view.\n06-BlazeposeThis is a demo show how it works in the 3-D space.It uses HTML5-Canvas without P5.js.You can attach it to more complicated frameworks like Three.js and Babylon.js\n","categories":["大前端"],"tags":["Javascript","大前端","Machine-Learning","动作捕捉"]},{"title":"React学习笔记(1) 类式组件相关","url":"/2022/03/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","content":"\n    待填坑\n\n\n    22.2.28 updated\n\n\n\n\n    prop-types\n\n\n    用于限定props的数据类型\n\n\nimport PropTypes from 'prop-types';class Greeting extends React.Component {  render() {    return (      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;    );  }}Greeting.propTypes = {  name: PropTypes.string};","categories":["大前端"],"tags":["Javascript","大前端","React"]},{"title":"Codeforces 1660F Promising String (hard version) 找规律+前缀和","url":"/2022/04/05/cf1660F/","content":"\n    题面\n\n\n\nF2. Promising String (hard version)\ntime limit per test2 seconds\nmemory limit per test256 megabytes\ninputstandard input\noutputstandard output\nThis is the hard version of Problem F. The only difference between the easy version and the hard version is the constraints.\n\nWe will call a non-empty string balanced if it contains the same number of plus and minus signs. For example: strings “+–+” and “++-+–” are balanced, and strings “+–”, “–” and “” are not balanced.\nWe will call a string promising if the string can be made balanced by several (possibly zero) uses of the following operation:\nreplace two adjacent minus signs with one plus sign.In particular, every balanced string is promising. However, the converse is not true: not every promising string is balanced.\nFor example, the string “-+—“ is promising, because you can replace two adjacent minuses with plus and get a balanced string “-++-“, or get another balanced string “-+-+”.\nHow many non-empty substrings of the given string 𝑠 are promising? Each non-empty promising substring must be counted in the answer as many times as it occurs in string 𝑠.\nRecall that a substring is a sequence of consecutive characters of the string. For example, for string “+-+” its substring are: “+-“, “-+”, “+”, “+-+” (the string is a substring of itself) and some others. But the following strings are not its substring: “–”, “++”, “-++”.\nInputThe first line of the input contains an integer 𝑡 (1≤𝑡≤104) —the number of test cases in the test.\nThen the descriptions of test cases follow.\nEach test case of input data consists of two lines. The first line consists of the number 𝑛 (1≤𝑛≤2⋅105): the length of 𝑠.\nThe second line of the test case contains the string 𝑠 of length 𝑛, consisting only of characters “+” and “-“.\nIt is guaranteed that the sum of values 𝑛 over all test cases does not exceed 2⋅105.\nOutputFor each test case, print a single number: the number of the promising non-empty substrings of string 𝑠. Each non-empty promising substring must be counted in the answer as many times as it occurs in string 𝑠.\nExampleinputCopy53+-+5-+—4\n\n7–+—+6+++—outputCopy24274NoteThe following are the promising substrings for the first three test cases in the example:\n𝑠[1…2]=”+-“, 𝑠[2…3]=”-+”;𝑠[1…2]=”-+”, 𝑠[2…3]=”+-“, 𝑠[1…5]=”-+—“, 𝑠[3…5]=”—“;𝑠[1…3]=”—“, 𝑠[2…4]=”—“.\n\n\n\n    题目大意\n\n\n    给你一个长度为n，只包含+-符号的字符串。连续两个-可以合并成一个+。问你该字符串中有多少子串满足，经过一些合并（或没有合并）后子串中+-号数量相等。\n\n\n\n    题解\n\n\n\n    \n        上结论：\n    \n    子串中-的个数比+多，且差值是3的倍数，则记一次贡献。\n\n\n\n    首先根据狄利克雷原理（抽屉原理），如果-的个数比+多于2个即一定有两个-相连。并且进行一次操作后，+-号的差异度会+3。那么就可以进行很多次操作将差异度变为0。\n\n\n\n    这题有小数据，那么对于小数据，O(n^2)的暴力为（假设一开始差异度为n）。\n\n\ncur=n;for (int i=0;i&lt;n;i++){    cur+=(s[i]=='+')?1:-1;    dp[i]=cur;    for (int j=0;j&lt;i;j++)        if (s[j]&gt;s[i] &amp;&amp; (s[j]-s[i])%3==0)            ans++;//[j,i]为合理区间}\n\n\n    考虑优化这个的暴力，如果把cur模3 ，那么当前右端点的贡献就是左侧所有比它大的%3剩余系的值。看到很多人写了一个log级的数据结构，但观察到差异度最大值为2n-1，不是很大，所以直接可以开个表记录一下，O(n)查询。\n\n\ninline void solve(){\tint n;\tcin&gt;&gt;n;\tstring s;\tcin&gt;&gt;s;\tint lim=2*n+1;\tint lst=n;\tvector&lt;int&gt; f (3,0);\tvector&lt;int&gt; cnt (lim,0);\tf[lst%3]++;\tcnt[lst]++;\tll ans=0;\tfor (int i=0;i&lt;n;i++)\t{\t\tint cur=lst;\t\tif (s[i]=='+')\t\t{\t\t\tf[cur%3]-=cnt[cur];//比cur小的不能用了\t\t\tcur++;\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\telse{\t\t\tcur--;\t\t\tf[cur%3]+=cnt[cur];//小于等于cur的都能用\t\t\tans+=f[cur%3];\t\t\tf[cur%3]++;\t\t\tcnt[cur]++;\t\t}\t\tlst=cur;\t}\tcout&lt;&lt;ans&lt;&lt;endl;}\n","categories":["算法竞赛"],"tags":["前缀和","字符串","找规律","Codeforces"]},{"title":"Codeforces19D Points 树套树","url":"/2022/03/18/cf19d/","content":"Codeforces 19D Points\n\nPete and Bob invented a new interesting game. Bob takes a sheet of paper and locates a Cartesian coordinate system on it as follows: point (0, 0) is located in the bottom-left corner, Ox axis is directed right, Oy axis is directed up. Pete gives Bob requests of three types:\nadd x y — on the sheet of paper Bob marks a point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is not yet marked on Bob’s sheet at the time of the request.remove x y — on the sheet of paper Bob erases the previously marked point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is already marked on Bob’s sheet at the time of the request.find x y — on the sheet of paper Bob finds all the marked points, lying strictly above and strictly to the right of point (x, y). Among these points Bob chooses the leftmost one, if it is not unique, he chooses the bottommost one, and gives its coordinates to Pete.Bob managed to answer the requests, when they were 10, 100 or 1000, but when their amount grew up to 2·105, Bob failed to cope. Now he needs a program that will answer all Pete’s requests. Help Bob, please!\nInput\nThe first input line contains number n (1 ≤ n ≤ 2·105) — amount of requests. Then there follow n lines — descriptions of the requests. add x y describes the request to add a point, remove x y — the request to erase a point, find x y — the request to find the bottom-left point. All the coordinates in the input file are non-negative and don’t exceed 109.\nOutput\nFor each request of type find x y output in a separate line the answer to it — coordinates of the bottommost among the leftmost marked points, lying strictly above and to the right of point (x, y). If there are no points strictly above and to the right of point (x, y), output -1.\nExample\nInput\n7\nadd 1 1\nadd 3 4\nfind 0 0\nremove 1 1\nfind 0 0\nadd 1 1\nfind 0 0\nOutput\n1 1\n3 4\n1 1\nInput\n13\nadd 5 5\nadd 5 6\nadd 5 7\nadd 6 5\nadd 6 6\nadd 6 7\nadd 7 5\nadd 7 6\nadd 7 7\nfind 6 6\nremove 7 7\nfind 6 6\nfind 4 4\nOutput\n7 7\n-1\n5 5\n\n题目大意\n在平面直角坐标系上进行一堆骚操作。Add表示添加(x,y) Remove删除(x,y) Find(x,y)表示查询(x,y)右边的最左边的上面的最下面那个点……\n题解\n\n建一棵线段树，每个叶子节点维护一棵平衡树，平衡树里记录横坐标为x的纵坐标（横坐标较大我们可以先离散化），线段树维护横坐标在这个区间里的纵坐标的最大值，所以查询的时候只要这个线段树结点维护的key小于我们要找到y这个区间里就没有解，在key值符合条件的情况下找横坐标最左边的一个点，找到这个横坐标再在平衡树里找恰好比y大的那个点即可。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn (int)2e5+10#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1struct Opt{\tchar s[10];\tint x,y;}opt[maxn];struct SGT{\tint l,r,key;}T[maxn&lt;&lt;2];#define ll long longint n,a[maxn],b[maxn],c[maxn];set&lt;int&gt; S[maxn];set&lt;int&gt;::iterator it;inline void build(int o,int l,int r){\tif (l&gt;r) return ;\tT[o].l=l;T[o].r=r;T[o].key=-1;\tif (l==r)return ;\tint mid=(l+r)&gt;&gt;1;\tbuild(lson,l,mid);build(rson,mid+1,r);\tT[o].key=max(T[lson].key,T[rson].key);}inline void update(int o,int x){\tint mid=(T[o].l+T[o].r)&gt;&gt;1;\tif (T[o].l==T[o].r &amp;&amp; T[o].l==x)\t{\t\tif (S[T[o].l].size())\t\t{\t\t\tit=(--S[T[o].l].end());\t\t\tT[o].key=*it;\t\t}\t\telse T[o].key=-1;\t\treturn ;\t}\tif (mid&gt;=x) update(lson,x);\telse update(rson,x);\tT[o].key=max(T[lson].key,T[rson].key);}inline int query(int o,int x,int y){\tif (T[o].r&lt;=x) return -1;\tif (T[o].key&lt;=y) return -1;\tif (T[o].l==T[o].r) return T[o].r;\tint t=query(lson,x,y);\tif (t==-1) return query(rson,x,y);\treturn t;}int cnt=0,ct2;int main(){\tcin&gt;&gt;n;\tfor (int i=1;i&lt;=n;i++)\t{\t\tscanf(\"%s%d%d\",opt[i].s,&amp;opt[i].x,&amp;opt[i].y);\t\ta[i]=opt[i].x;\t}\tsort(a+1,a+1+n);\tint t=unique(a+1,a+1+n)-a-1;\tfor (int i=1;i&lt;=n;i++) b[i]=lower_bound(a+1,a+1+t,opt[i].x)-a;\tbuild(1,1,maxn);\tfor (int i=1;i&lt;=n;i++)\t{\t\tif (opt[i].s[0]=='a')\t\t{\t\t\tS[b[i]].insert(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}else\t\tif (opt[i].s[0]=='r')\t\t{\t\t\tS[b[i]].erase(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}\t\telse{\t\t\tint ans=query(1,b[i],opt[i].y);\t\t\tif (ans==-1) cout&lt;&lt;-1&lt;&lt;endl;\t\t\telse{\t\t\t\tprintf(\"%d %d\\n\",a[ans],*S[ans].upper_bound(opt[i].y));\t\t\t}\t\t}\t}}","categories":["算法竞赛"],"tags":["Codeforces","线段树","树套树","数据结构"]},{"title":"codeforces 24D Broken Robot[有后效性DP,高斯消元]","url":"/2022/03/19/cf24d/","content":"来自lyd的书，给定一张N*M的棋盘和一个初始位置，机器人位于初始位置，每次等概率地选择停在原地，向左移动一格或者向下移动一格。不能移出棋盘，求机器人从初始位置走到最后一行的任意一个位置的数学期望。（1&lt;=N,M&lt;=1,000)。\n注意很多数学期望DP都会采取倒推的方式进行我们记F[i][j]表示从(i,j)走到最后一行所需要的期望值\n位于第一列\n位于最后一列\n剩余情况\n因为每一行内部可以相互转移，所以这个dp是有后效性的，但从下一行往上一行推的过程无后效性，对于行内有后效性的转移，使用高斯消元，将下一行已经得到的数据作为已知量。通过将这些方程移项可以推出很多方程组，将它们用矩阵表示，以M=5为例\n\n观察后发现这种矩阵叫 三对角矩阵每一行消元只需要直接用下一行相邻的数据进行一次消元就行了，复杂度是线性的，加上每一行往上的无后效性递推，总体的复杂度是O(NM)。注意到M=1的时候要进行特殊处理，将第一个方程带入消元后发现每一行等于下一行的期望+2。在消元过程中很多细节的加加减减和系数处理都要在纸上列出算式消元后才能处理，要注意。\n\ndouble f[maxn],a[maxn][maxn],b[maxn];int n,m,x,y; void gauss(){\tfor (int i=1;i&lt;m;i++)\t{\t\tdouble rt=a[i+1][i]/a[i][i];\t\ta[i+1][i]-=rt*a[i][i];\t\ta[i+1][i+1]-=rt*a[i][i+1];\t\tb[i+1]-=rt*b[i];\t}\tf[m]=b[m]/a[m][m];\tfor (int i=m-1;i&gt;=1;i--)\t{\t\tf[i]=(b[i]-f[i+1]*a[i][i+1])/a[i][i];\t}}//mainint main(){\t//freopen(\"Untitled.txt.in\",\"r\",stdin);\t//freopen(\"Untitled.txt.out\",\"w\",stdout);\tios::sync_with_stdio(false);\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;\tif (m==1)\t{\t\tdouble ans= (double) (n-x) *2;\t\tcout&lt;&lt;ans&lt;&lt;endl;\t\treturn 0;\t}\tfor (int i=n-1;i&gt;=x;i--)\t{\t\ta[1][1]=(double)-2/3;\t\ta[1][2]=(double)1/3;\t\ta[m][m-1]=(double)1/3;\t\ta[m][m]=(double)-2/3;\t\tb[1]=(double)((double)-1/3)*f[1]-1;\t\tb[m]=(double)((double)-1/3)*f[m]-1;\t\tfor (int j=2;j&lt;m;j++)\t\t{\t\t\ta[j][j-1]=a[j][j+1]=(double)1/4;\t\t\ta[j][j]=(double)-3/4;\t\t\tb[j]=(double)((double)-1/4)*f[j]-1;\t\t}\t\tgauss();\t\t}\t\tcout&lt;&lt;setprecision(10)&lt;&lt;f[y]&lt;&lt;endl;\treturn 0;}","categories":["算法竞赛"],"tags":["Codeforces","动态规划","有后效性动态规划","高斯消元"]},{"title":"Google Code Jam 2022-QR-T4-Chain Reactions","url":"/2022/04/03/gcj22ET4/","content":"\n    题面\n\n\nProblem\nWile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of N modules indexed 1,2,…,N. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called initiators. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a chain reaction.\nEach of the N modules has a fun factor Fi. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\nFor example, suppose Wile has 4 modules with fun factors F1=60,F2=20,F3=40, and F4=50 and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\nExample in statement when activating 4 then 3.\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of max(50,20,60)=60. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of 60+40=100.\nExample in statement when activating 3 then 4.\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of max(40,60)=60. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of max(50,20)=50, and an overall fun for the session of 60+50=110.\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.\nInputThe first line of the input gives the number of test cases, T. T test cases follow, each described using 3 lines. Each test case starts with a line with a single integer N, the number of modules Wile has. The second line contains N integers F1,F2,…,FN where Fi is the fun factor of the i-th module. The third line contains N integers P1,P2,…PN. If Pi=0, that means module i points at the abyss. Otherwise, module i points at module Pi.\nOutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum fun Wile can have by manually triggering the initiators in the best possible order.\nLimitsMemory limit: 1 GB.1≤T≤100.1≤Fi≤109.0≤Pi≤i−1, for all i.Test Set 1 (Visible Verdict)Time limit: 5 seconds.1≤N≤10.Test Set 2 (Visible Verdict)Time limit: 5 seconds.1≤N≤1000.Test Set 3 (Hidden Verdict)Time limit: 10 seconds.1≤N≤100000.SampleSample Inputsave_altcontent_copy3460 20 40 500 1 1 253 2 1 4 50 1 1 1 08100 100 100 90 80 100 90 1000 1 2 1 2 3 1 3Sample Outputsave_altcontent_copyCase #1: 110Case #2: 14Case #3: 490Sample Case #1 is the one explained in the problem statement.\nIn Sample Case #2, there are 4 initiators (modules 2 through 5), so there are 4 chain reactions. Activating them in order 3,5,4,2 yields chains of fun 3,5,4,2 for an overall fun of 14. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\nIn Sample Case #3, an optimal activation order of the 5 initiators is 4,5,7,6,8.\n\n\n\n    题目大意\n\n\n    给你一大坨点带权的森林。对于每棵树，每一次选择一个叶子结点一路走到根，对答案的贡献是这条路径上的最大值，并且走完之后路径上的点权就废了。可以知道改变选择叶子结点的顺序会得到不同的答案。现在求整个森林得到的最大答案是啥。\n\n\n\n    思路\n\n\n\n    写完三题过关就没看后面的，这两天补一下。\n\n\n\n    森林里每棵树是独立的。分治一下，如果是一个孤立的点，答案就是本身的权值。如果只有一个儿子，记一个结点的答案是f(i)，那么对于父亲u，答案就是max{val[u],f(i)}。\n\n\n\n    当有多个儿子的时候，其实就按照题面那个动态图的意思搞就行（谷歌用户体验牛逼，吹一把，题面都会动，太良心了）。其实这个时候就是针对所有儿子，选中的第一个就会把当前结点的值跑掉。我们已经dfs完了所有儿子，可以意会到，贪心地选择最小的一个答案，把它和val[u]比一下大小。如果比val[u]来得大，那么val[u]肯定对答案没有贡献。如果比val[u]小，那么相当于val[u]顶替掉最小的那份答案，而其他比之大的答案都应该直接贡献到最后的ans里。\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll N=100005;ll vis[N],val[N];vector&lt;ll&gt; G[N];ll n,ans,f;ll dfs(ll u,ll fa){    vis[u]=1;    vector&lt;ll&gt; dp;    ll sz=G[u].size();    for (ll i=0;i&lt;sz;i++)    {        ll v=G[u][i];        ll p=dfs(v,u);        dp.push_back(p);    }    sort(dp.begin(),dp.end());    if (sz==0)        return val[u];    for (ll i=1;i&lt;sz;i++)        ans+=dp[i];    return max(dp[0],val[u]);}int main(){    ll T;    cin&gt;&gt;T;    for (ll t=1;t&lt;=T;t++)    {        cin&gt;&gt;n;        for (ll i=1;i&lt;=n;i++)            cin&gt;&gt;val[i];        for (ll i=1;i&lt;=n;i++)            G[i].clear();        for (ll i=1;i&lt;=n;i++)        {            ll fa;            cin&gt;&gt;fa;            G[fa].push_back(i);        }        f=ans=0;        memset(vis,0,sizeof(vis));        for (ll i=1;i&lt;=n;i++)        {            if (!vis[i])                f+=dfs(i,-1);        }        ans=ans+f;        cout&lt;&lt;\"Case #\"&lt;&lt;t&lt;&lt;\": \";        cout&lt;&lt;ans&lt;&lt;endl;    }}","categories":["算法竞赛"],"tags":["比赛","Google Code Jam","贪心","分治"]},{"title":"hello-world","url":"/2022/03/18/hello-world/","content":"好像有那么几年不写blog了...为了督促自己继续努力刷题/学习还是在这里开了一个，github.io真的方便，会在这里记录一些学习的历程和各种碎碎念。那么继续温柔地推翻这个世界吧～\n#include &lt;bits/stdc++.h&gt;int main(){    std:cout&lt;&lt;\"Hello World\"&lt;&lt;endl;}","categories":["生活和碎碎念"],"tags":["碎碎念"]},{"title":"ICPC2022昆明站补题","url":"/2022/04/22/icpc2022Kunming/","content":"\n    K. King of Gamers\n\n\n\n    题目大意\n\n\n    给了你一个的比例，从第1次开始，之前\n胜利或失败都统计进去，有一个获胜比。如果当前的\n比例比给出的比例大，那么就会这一次就会输，反之就赢，问n次比赛最后的胜利次数。\n\n\n    Solution\n\n\n\n    签到题，打表可知。数学推理的话，假设最后的答案是x，可以知道分母是n。\n    有，移一下项\n    有，把x代进n-1，去判断一下最后一次🉑️不🉑️。\n    省去检验的话可以发现最后答案是\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int T;ll n,a,b;int main(){    cin&gt;&gt;T;    while (T--)    {        cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;        ll ans=(n-1)*a/b+1;        cout&lt;&lt;ans&lt;&lt;endl;    }}\n\n\n\n    D. Divisions\n\n\n\n\n    题目大意\n\n\n    构造一个序列，这个序列可以被分为一个非升和一个非降的自序列。\n现在要求你构造的这个序列一共有k种不同的分法。\n\n\n    Solution\n\n\n    0或1的时候糊两个数据特判一下。\n\n\n    剩下的数据，考虑构造。如果整个序列是空的，那么显然答案只有一种分法,{}{}。我们现在加入第一个数进来，假如是1，可以放在左右任意一个集合中，答案是2。\n    在刚才的2个集合的基础上，可以放进任意一个集合里，又把答案*2。所以这样可以凑出所有种。考虑非的情况，如果我们加一个比之前所有数都要大的数。可以知道\n    如果要把新的那个数塞进非降序列，必须把非降序列清空，所以答案会比刚才多1。\n    这个时候如果再加一个2进来，答案会+2，然后是+4。如果再加一个比2大的数进来，那么又反复从1开始计算。如此一来就可以把所有的清空都覆盖进去了。\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int T;ll n,a,b;int main(){   cin&gt;&gt;n;   if (n==0)   {       puts(\"4\");       puts(\"8 9 4 6\");       return 0;   }   if (n==1)   {       puts(\"6\");       puts(\"1 1 4 5 1 4\");       return 0;   }   ll st=1,cur=0,ans=1;   vector&lt;int&gt; G;   while (ans&lt;n)   {       if (ans+(1ll&lt;&lt;cur)&lt;=n)       {           ans+=(1&lt;&lt;cur);           cur++;           G.push_back(st);       }       else{           st++;           cur=0;       }   }   int L=G.size();   cout&lt;&lt;L&lt;&lt;endl;   for (int i=0;i&lt;L;i++)       cout&lt;&lt;G[i]&lt;&lt;\" \";   return 0;}\n\n\n    F.Find the Maximum\n\n\n\n    题目大意\n\n\n    给你一棵点带权的树。让你找出一条路径。路径上所有点权的平均值是ave，现在要你求整个树的最大的\n    \n\n\n    Solution\n\n\n 套了层皮，那个二次函数的x就直接找顶点就行了。实际上就是找树上平均值（的绝对值）最大的一条路径。然后可以二分，但这题可以给出一个引理，就是树上路径平均值最大的话结点一定不会超过3个。\n 比如说现在有了9，8，9。那么再加一个如果是9，那么直接9,9就最大了，如果比9来得小，那么还不如9，8，9来得优。同理再序列里找连续的平均值最大的一串数也是这个道理。\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long long#define maxn 1000010#define ld long doubleusing namespace std;int n;int w[maxn];vector&lt;int&gt; val[maxn];int main(){    cin&gt;&gt;n;    for (int i=1;i&lt;=n;i++)        cin&gt;&gt;w[i];    for (int i=1;i&lt;n;i++)    {        int x,y;        cin&gt;&gt;x&gt;&gt;y;        val[x].push_back(w[y]);        val[y].push_back(w[x]);    }    for (int i=1;i&lt;=n;i++)        sort(val[i].begin(),val[i].end());    ld ans=-1e100;    for (int i=1;i&lt;=n;i++)    {        int N=val[i].size();        ld cur=(1.0*w[i]+val[i][N-1])/2;        ans=max(ans,cur);        cur=(1.0*w[i]+val[i][0])/2;        ans=max(ans,-cur);        if (val[i].size()&gt;=2) {            cur = (1.0 * w[i] + val[i][N - 1] + val[i][N - 2]) / 3;            ans = max(ans, cur);            cur=(1.0*w[i]+val[i][0]+val[i][1])/3;            ans=max(ans,-cur);        }    }    ans=ans*ans/4;    cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;ans&lt;&lt;endl;    return 0;}\n\n\n\n    B.Blocks\n\n\n\n题目大意\n\n\n    平面上给你n个矩阵，坐标都为正整数，给你左下角端点和右上角端点。然后给你另一个矩阵W*H（题目感觉有漏洞，没有说这个W*H就是最大的。\n每次等概率地选择n个矩阵中的一个把它涂黑，问最后把W*H涂黑的期望次数是多少。n非常小，小于或等于10。\n\n\n    Solutions\n\n\n    n这么小，一眼状压。把坐标离散化一下，会发现总共也没多少个点，对于每一个压缩的状态，直接暴力涂点判断即可。\n\n\n    经典的期望dp模型，涂格子，现在有n个格子，每次随机涂一个，问涂满m个格子的期望数。\n    经典逆推。f[i]表示已经涂了i个格子，到涂满m个还要多少步。\n\n\n有，，转化一下\n，这一题f[i+1]是把当前状态异或上1后的状态相加，就是(n-i)个f[S^k]，所以把它们累加后，加上n，除以(n-i)就得到了f[i]。注意离散化和暴力涂格子别写炸，离散化后给的是格点，涂的是格子，记得循环到n-1（一开始写炸了）\n\n\n#include &lt;bits/stdc++.h&gt;#define ll long long#define maxn 50const int mod=998244353;using namespace std;ll qpow(ll x,ll n){    ll ans=1;    while (n)    {        if (n&amp;1)            ans=1ll*ans*x%mod;        x=1ll*x*x%mod;        n&gt;&gt;=1;    }    return ans;}struct Rect{    int x1,y1,x2,y2;}rec[maxn];int n,W,H;int w[50],h[50],w1=0,h1=0;int state[(1&lt;&lt;10)+1],cnt[(1&lt;&lt;10)+1];int vis[50][50];ll dp[(1&lt;&lt;10)+1];int check(){    for (int x=1;x&lt;W;x++)        for (int y=1;y&lt;H;y++)            if (vis[x][y]==0)            {                return 0;            }    return 1;}int main(){   // cin&gt;&gt;n;   int T;   cin&gt;&gt;T;   while (T--)   {       w1=0;       memset(cnt,0,sizeof(cnt));       memset(dp,0,sizeof(dp));       h1=0;       cin&gt;&gt;n;       cin&gt;&gt;W&gt;&gt;H;       w[++w1]=W;       h[++h1]=H;       for (int i=1;i&lt;=n;i++)       {           cin&gt;&gt;rec[i].x1&gt;&gt;rec[i].y1;           w[++w1]=(rec[i].x1);           h[++h1]=rec[i].y1;           cin&gt;&gt;rec[i].x2&gt;&gt;rec[i].y2;           w[++w1]=(rec[i].x2);           h[++h1]=rec[i].y2;       }       sort(w+1,w+1+w1);       sort(h+1 ,h+1+h1);       w1=unique(w+1,w+1+w1)-w-1;       h1=unique(h+1,h+1+h1)-h-1;       W=lower_bound(w+1,w+1+w1,W)-w;       H=lower_bound(h+1,h+1+h1,H)-h;       for (int i=1;i&lt;=n;i++)       {           rec[i].x1=lower_bound(w+1,w+1+w1,rec[i].x1)-w;           rec[i].x2=lower_bound(w+1,w+1+w1,rec[i].x2)-w;           rec[i].y1=lower_bound(h+1,h+1+h1,rec[i].y1)-h;           rec[i].y2=lower_bound(h+1,h+1+h1,rec[i].y2)-h;       }       int S=(1&lt;&lt;n)-1;       for (int s=S;s&gt;=0;s--)       {           state[s]=1;           memset(vis,0,sizeof(vis));           for (int k=1;k&lt;=n;k++)           {               if (s&amp;(1&lt;&lt;(k-1)))               {                   cnt[s]++;                   for (int x=rec[k].x1;x&lt;rec[k].x2;x++)                       for (int y=rec[k].y1;y&lt;rec[k].y2;y++)                           vis[x][y]=1;               }           }           state[s]=check();       }       if (!state[S])       {           puts(\"-1\");           continue;       }       for (int s=S;s&gt;=0;s--)       {           if (state[s]==1)           {               dp[s]=0;               continue;           }           ll sum=0;           for (int k=1;k&lt;=n;k++)           {               if (!(s&amp;(1&lt;&lt;(k-1))))               {                   sum=(sum+dp[s|(1&lt;&lt;(k-1))])%mod;               }               ll inv=qpow(n-cnt[s],mod-2);               dp[s]=(ll)(sum+n)*inv%mod;               dp[s]%=mod;           }       }       cout&lt;&lt;dp[0]&lt;&lt;endl;   }}\n\n\nE.Easy String Problem\n\n\n\n题目大意\n\n\n\n    给你一个字典集大小为n的长度为n的字符串。现在对于每一个询问L，R，问你把包含[L,R]的子串删掉后能得到多少本质不同的字符串数量。\n\n\n\n    Solutions\n\n\n    首先删除后本质相同的字符串，删掉的字符串长度也是相同的。考虑本质相同的字符串的情况，如果[l,r]（有l&lt;=L&lt;=R&lt;=r)，有l-1=r，那么[l-1,r-1]和[l,r]本质就是相同的，其实不难理解。\n    那么对于每一个[L,R]的询问，所有的可行方案数量是L*(n-R+1)，那么我们只要把重复的剪掉就行，重复的数量就是[1,L]和[R,n]这两个区域里相同的字母的个数就成了，然后就是经典莫队了。\n\n\n//// Created by Administrator on 2022/4/22.//#include &lt;bits/stdc++.h&gt;#define maxn 100010#define ll long longusing namespace std;int sq,n,q;int a[maxn];ll ans[maxn],res;int cl[maxn],cr[maxn];int L,R;struct Seg{    int id,l,r;    bool operator &lt; (const Seg &amp; b) const{        if (l/sq!=b.l/sq)            return l&lt;b.l;        if (l/sq&amp;1)            return r&lt;b.r;        return r&gt;b.r;    }}req[maxn];int main(){    cin&gt;&gt;n;    sq=sqrt(n);    for (int i=1;i&lt;=n;i++)        cin&gt;&gt;a[i];    cin&gt;&gt;q;    for (int i=1;i&lt;=q;i++)    {        req[i].id=i;        cin&gt;&gt;req[i].l&gt;&gt;req[i].r;    }    sort(req+1,req+1+q);    L=1,R=n;    res=0;    for (int i=1;i&lt;=q;i++)    {        while (L&lt;req[i].l)        {            res+=cr[a[L]];            cl[a[L]]++;            L++;        }        while (L&gt;req[i].l)        {            L--;            cl[a[L]]--;            res-=cr[a[L]];        }        while (R&lt;req[i].r)        {            R++;            cr[a[R]]--;            res-=cl[a[R]];        }        while (R&gt;req[i].r)        {            res+=cl[a[R]];            cr[a[R]]++;            R--;        }        ans[req[i].id]=1ll*L*(ll)(n-R+1)-res;    }    for (int i=1;i&lt;=q;i++)        cout&lt;&lt;ans[i]&lt;&lt;endl;    return 0;}","categories":["算法竞赛"],"tags":["比赛","补题","ICPC"]},{"title":"Metal优化M系列Mac芯片机器学习(Tensorflow）","url":"/2023/06/10/metalTensorflow/","content":"\n    Intro\n\n\n    早就听说M卡自带的GPU跑机器学习模型也还是可以的，但是一直没试，今天折腾了一下；发现时至2023年，Tensorflow和Pytorch都已经通过安装Metal插件来使用M系列芯片的GPU加强运算速度了。因为最近做的项目还是用的TF，先折腾了一下TF端的优化。效果还是挺感人的。\n\n\n\n    Preparation\n\n\n\n    因为针对M卡优化的那个环境用的是MiniForge,平常用的Anaconda，得先把conda环境切到MiniForge。\n\n\n$ conda env list\n\n\n    先看一下自己conda的环境，如果现在是Anaconda，需要切到MiniForge，上面那段我本地打出来是这样\n\n\n# conda environments:#                         /Users/primopan/anaconda3base                  *  /Users/primopan/miniforge3tfm1                     /Users/primopan/miniforge3/envs/tfm1\n\n\n    如果想swift一下Anaconda和MiniForge，假设现在咱们在Anaconda环境下，你需要复制一下上面MiniForge的地址，然后\n\n\n$ /Users/primopan/miniforge3/conda init zsh$ /Users/primopan/miniforge3/conda init bash\n\n\n    Terminal会显示no change，但是没关系，关掉终端再开一下，检查环境，就已经切换过来了。然后我们开一下环境。\n\n\n$ conda create --name tfm1 python==3.9$ conda activate tfm1\n\n    接着安装预制环境和tf的macos和metal插件\n\n\n$ conda install -c apple tensorflow-deps$ pip install tensorflow-macos$ pip install tensorflow-metal\n\n\n    理论上装完了就可以了。我们terminal 开个Python 试一试能不能调用GPU\n\n\n&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; tf.__version__'2.12.0'&gt;&gt;&gt; tf.config.list_physical_devices()[PhysicalDevice(name='/physical_device:CPU:0', device_type='CPU'), PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')]\n\n\n    可以看到输出的那一坨设备里面有GPU的话就说明可以调用GPU了，废话不多说，开一个最简单的图像分类训练模型试一下。\n\n\nimport tensorflow as tfcifar = tf.keras.datasets.cifar100(x_train, y_train), (x_test, y_test) = cifar.load_data()model = tf.keras.applications.ResNet50(    include_top=True,    weights=None,    input_shape=(32, 32, 3),    classes=100,)loss_fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False)model.compile(optimizer=\"adam\", loss=loss_fn, metrics=[\"accuracy\"])model.fit(x_train, y_train, epochs=5, batch_size=64)\n\n\n    跑了5个epoch，每个epoch差不多1分钟左右的样子。我们deactivate一下当前的环境，用只有CPU的环境跑，一个epoch差不多要380s，是开GPU的六倍多。下午刚去入了一个3060Ti，明天看看M1和CUDA环境下的3000块钱左右的卡PK能获得什么成绩吧。\n","tags":["deep learning","机器学习"]},{"title":"React学习笔记(2) Hooks","url":"/2022/04/03/react2/","content":"\n    22.4.3 updated\n\n\n    关于hooks\n\n\n    React16.8的版本更新了Hooks功能。意味着函数式组件也可以拥有state属性。自此，类式组件基本完全可以被函数式组件替代。（除非要利用生命周期进行一些骚操作）。这也让利用React进行的开发更贴近\"函数式编程\"的潮流。\n\n\n\n  useState()\n\n\nfunction App() {  const [value,setValue]= useState(0);  return (      &lt;div&gt;         &lt;button onClick={()=&gt;{           setValue(value+1)         }}&gt;click to add 1&lt;/button&gt;        &lt;div&gt;           value={value}        &lt;/div&gt;      &lt;/div&gt;  );}//注意到如上代码使用了useState//[]中两个参数//第一个相当于class中state中的一个属性（变量），而第二个参数是一个方法（函数），用以改变这个属性的值。//useState()括号中为该属性的初始值//当我们需要改变value的值时，在class中this.setState({value:this.state.value+1})//而在hooks中直接setValue(value+1)//不要太方便，且省去了各种this来this去\n\n\n  不过来点面试题会发现其实看上去简单的东西也会有很多反直觉的坑。师哥给我丢了一道。\n\n\nfunction App() {    const [n, setN] = useState(0);     return (          &lt;div&gt;            &lt;h1&gt;{n}&lt;/h1&gt;            &lt;button onClick={() =&gt; setN(x =&gt; x + 1)}&gt;+1&lt;/button&gt;            &lt;button onClick={() =&gt; setTimeout(() =&gt; console.log(n), 3000)}&gt;log&lt;/button&gt;          &lt;/div&gt;        )}//先点log，然后立即点+1,3s后会打印出啥//答案是0//因为函数式组件在+1后进行了刷新，相当于重新执行了一下这个函数，并且创建了一个新的n//但是console.log中的n是通过闭包捕获的，函数第一次执行时的n,所以无论函数再怎么被翻江倒海//打印出的值始终是第一次的n\n\n\n    useEffect()\n","categories":["大前端"],"tags":["Javascript","大前端","React"]},{"title":"CUC-Spring-Training字符串基础算法","url":"/2022/05/04/%E5%A4%87%E8%AF%BE%E7%AC%94%E8%AE%B0/","content":"\n    A - Oulipo\n\n\n\n    纯纯KMP模板题，通过率100%，应该没有什么问题。每一次匹配到直接把答案+1就行了。\n\n\n\n    B - Reverse String\n\n\n\n    过这题的同学都是直接brute force的，自然没有什么问题，官方题解也是直接暴力过的。但是我们也可以使用hash或者z-algorithm优化dfs过程。比如dfs中向右匹配的过程可以用z算法找模式串和当前串的LCP（最长公共前缀），反之往左走可以把两个串倒过来求一次z。（哈希同理），可以大大优化时间复杂度，如果把数据范围调大，这些做法值得同学们思考一下。\n\n\n    丢个py代码给各位尝尝鲜\n\n\nq = int(input())for i in range(q):\ts = input()\tt = input()\tn = len(s)\tm = len(t)\tans = False\tfor i in range(n):\t\tfor j in range(0, n - i):\t\t\tk = m - 1 - j\t\t\tif i + j &lt; k:\t\t\t\tcontinue                                 \t\t\tl1 = i\t\t\tr = i + j\t\t\tl2 = r - k                                \t\t\tif s[l1:r+1] + s[l2:r][::-1] == t:\t\t\t\tans = True\t\tprint('YES' if ans else 'NO')\n\n    C - 于是他错误的点名开始了 \n\n\n    Trie裸题，其实标程就是下发文件夹中的Trie.cpp，没能理解Trie的同学可以仔细阅读代码加深理解。\n\n\n    如果不是字符串专场，或者说在正儿八经的比赛里遇到这种题，同学们也完全可以开一个map，来解决这道题目，STL的功能非常强大，本着不重复发明轮子的原则，希望同学们善于利用。\n\n\n    upd...谢谢同学提醒，下发的代码中Trie放错代码了，我的锅我的锅。\n\n\n#include &lt;cstdio&gt;const int N = 500010;char s[60];int n, m, ch[N][26], tag[N], tot = 1;int main() {  scanf(\"%d\", &amp;n);  for (int i = 1; i &lt;= n; ++i) {    scanf(\"%s\", s + 1);    int u = 1;    for (int j = 1; s[j]; ++j) {      int c = s[j] - 'a';      if (!ch[u][c])        ch[u][c] =            ++tot;  // 如果这个节点的子节点中没有这个字符，添加上并将该字符的节点号记录为++tot      u = ch[u][c];  // 往更深一层搜索    }    tag[u] = 1;  // 最后一个字符为节点 u 的名字未被访问到记录为 1  }  scanf(\"%d\", &amp;m);  while (m--) {    scanf(\"%s\", s + 1);    int u = 1;    for (int j = 1; s[j]; ++j) {      int c = s[j] - 'a';      u = ch[u][c];      if (!u) break;  // 不存在对应字符的出边说明名字不存在    }    if (tag[u] == 1) {      tag[u] = 2;  // 最后一个字符为节点 u 的名字已经被访问      puts(\"OK\");    } else if (tag[u] == 2)  // 已经被访问，重复访问      puts(\"REPEAT\");    else      puts(\"WRONG\");  }  return 0;}\n\n\nD - Password \n\n\n\n    题目意思是说找到一个非前缀且非后缀的substring，使得它的长度最长，且它等于与它长度相同的前缀和后缀。也就是说找到一个最长的前缀，使得它也是一个后缀，并且这个子串在字符串中间出现过。\n\n\n    KMP和Z-algorithm皆可。KMP的话直接从pi[n]入手，如果pi[n]所代表的前缀在字符串中某个非前缀/后缀的位置出现过，那么这就是可行解，这利用了pi[n]是当前\"最长匹配前缀\"的性质。\n\n\n\n    如果用z算法，也比较直观。\n    处理出z数组后，我们记录前i项的z的最大值\n    对于第i+1项，如果z[i+1]+i==len&amp;&amp;max[i]&gt;=z[i+1],即从i+1开始能匹配到后缀,且前面存在一个相同的串，他所代表的串就是符合条件的.\n\n\nKMP By 本场Rank1同学\n#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt; using namespace std;char p[2000007];int nnext[2000007];int book[2000007];void GetNext(){\tmemset(nnext,0,sizeof(nnext));\tint k = strlen(p);    nnext[0]=-1;    int i = 0;\tint j = -1;    while(i&lt;k)    {        if (j==-1||p[i]==p[j])        {            ++i;            ++j;            nnext[i] = j;        }        else            j = nnext[j];    }\tfor(int i=0;i&lt;k;++i)\t++book[nnext[i]];}int main(){\twhile(~scanf(\"%s\",p))\t{\t\tGetNext();\t\tint len = strlen(p);\t\tint judge = 0;\t\twhile(nnext[len]!=0)\t\t{\t\t\tif(book[nnext[len]])\t\t\t{\t\t\t\tfor(int i=0;i&lt;nnext[len];++i)\t\t\t\tprintf(\"%c\",p[i]);\t\t\t\t++judge;\t\t\t\tbreak;\t\t\t}\t\t\tlen = nnext[len];\t\t}\t\tif(judge==0)\t\tprintf(\"Just a legend\");\t\tprintf(\"\\n\");\t}\treturn 0;}\n\nZ-algorithm:\n#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int z[1000010],n,m,r,l;char b[1000010];int maxn=0;int main(){    scanf(\"%s\",b);    m=strlen(b);    for (int i=1;i&lt;=m;i++)    {        if (i&gt;r)        {            int t=i,bg=0;            while (b[t]==b[bg])                t++,bg++;            z[i]=bg;            r=t-1;            l=i;        }        else        {            if (z[i-l]&lt;r-i+1) z[i]=z[i-l];            else            {                int t=r+1,bg=r-i+1;                while (b[t]==b[bg])                    t++,bg++;                z[i]=bg;                r=t-1;                l=i;            }        }    }    int nw=0;    for (int i=1;i&lt;m;i++)    {        if (i+z[i]==m&amp;&amp;nw&gt;=z[i])            maxn=max(maxn,z[i]);        nw=max(nw,z[i]);    }    if (maxn==0) printf(\"Just a legend\");    for (int i=0;i&lt;maxn;i++)        printf(\"%c\",b[i]);}\n\n\nE - Spy Syndrome 2\n\n\n    给你一个长度为N的文本串，这个文本串是由一堆 单词拆分开之后每个单词变小写并翻转的来的，现在给你这个长度为N的字符串，还给你他的原来的组成成分，你要还原这句话，其中有的单词可能是多余的。\n\n\n\n    其实还是字典树的裸题，不过既然它翻转过来了，我们就直接倒序建立字典树，倒序跑Trie匹配，最后再将单词倒序输出即可。\n\n\nBy 本场Rank2同学\n#include&lt;bits/stdc++.h&gt;using namespace std;//既有单词建树、reverse原、break原、dfs、倒序outputconst int maxn=1e5+5;const int maxx=1e6+5;int tr[maxx][30],num[maxx],n,m,tot,dp[maxn];string s[maxn];string a;vector&lt;int&gt;v;void build_trie(string&amp; s,int No) {\tint p=0;\tfor (auto &amp;j : s) {\t\tint c;\t\tif(j&gt;='a'&amp;&amp;j&lt;='z')c=j-'a';\t\telse if(j&gt;='A'&amp;&amp;j&lt;='Z')c=j-'A';\t\tif(!tr[p][c]) tr[p][c] = ++tot;\t\tp=tr[p][c];\t}\tnum[p]=No;}void find(int t){\tint p=0;\tfor(int i=t;i&lt;n;i++){\t\tint c=a[i]-'a';\t\tif(!tr[p][c])return;\t\tp=tr[p][c];\t\tif(num[p])dp[i+1]=num[p];//mark the position\t}}void dfs(int k=n){//corret the order\tif(!k)return;\tint tmp=s[dp[k]].size();\tv.push_back(dp[k]);\tdfs(k-tmp);}int main(){\tscanf(\"%d\",&amp;n);\tcin&gt;&gt;a;\tscanf(\"%d\",&amp;m);\tfor(int i=1;i&lt;=m;i++){\t\tcin&gt;&gt;s[i];\t\tbuild_trie(s[i],i); \t}\treverse(a.begin(),a.end());\tfind(0);\tfor(int i=1;i&lt;=n;i++){\t\tif(!dp[i])continue;\t\tfind(i);\t}\tdfs();//\tcout&lt;&lt;\"ok\"&lt;&lt;endl;\tfor(auto &amp;r:v)cout&lt;&lt;s[r]&lt;&lt;\" \";\tcout&lt;&lt;endl;  \treturn 0;\t} \n\n\nF - Hash Killer II \n\n\n\n 很有意思的题目，要你出一个字符串卡掉单哈希。\n\n\n\n    考察生日攻击，关于生日攻击，知乎上有一个回答讲的很不错。\n    \n        点我点我\n    \n\n\n\n    这题用到一个结论，在n个数里随机选数，选了个数后，发生冲突的概率就极大。\n    这题的mod数是1e9+7，我们把n调成1e5（就是最大值）,l选一个排列组合后足够大的数（比如20），直接随机输出一个串，就满足条件了。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    srand(time(0));    cout &lt;&lt; 100000 &lt;&lt; \" \" &lt;&lt; 20 &lt;&lt; endl;    for (int i = 1; i &lt;= 100000; i++)        cout &lt;&lt; (char)(rand() % 26 + 'a');}\n\n\nG - Test \n\n\n\n给你三个字符串，找⼀个字符串(它的⼦串含有以上三个字符串)，输出此字符串的最小⻓度。\n\n\n    显然有种拼接顺序，我们直接暴力枚举一下拼接顺序。（next_permutation)。因为要求最小长度，我们自然希望拼接时能尽量把重叠部分合并。那我们自然就希望后一个串的前缀和前一个串的后缀能尽可能多地重叠！那么用KMP/Z拼接的思路就非常明确了。\n\n\n一鱼两吃,Z-algorithm:\nint f[maxn];string S[4];int ord[3]={0,1,2};int ans=maxlongint;//z-algorithminline string skr(string a,string b){\tstring T=a+'$'+b;//merge a &amp; b\tint n=a.length();\tint m=b.length();\tint Len=n+m+1;\tf[0]=Len;\tint j=1,k;\tfor (int i=1;i&lt;Len;i=k)\t{\t\tif (j&lt;i) j=i;\t\twhile (T[j-i]==T[j] &amp;&amp; j&lt;Len)\t\t\tj++;\t\tf[i]=j-i;\t\tk=i+1;\t\twhile (k+f[k-i]&lt;j) k++;\t}\tint Lim=m+1;\tfor (int i=n+1;i&lt;Len;i++)\t{\t\tif(f[i]==n)\treturn b;\t\tif (i+f[i]&gt;=Len){\t\t\tLim=min(Lim,i-n);break;\t\t}\t}\tstring cur;\tcur=b.substr(0,Lim-1)+a;\treturn cur;}//mainint main(){\tcin&gt;&gt;S[0]&gt;&gt;S[1]&gt;&gt;S[2];\tdo {\t\tans=min(ans,(int)skr(skr(S[ord[0]],S[ord[1]]),S[ord[2]]).length());\t}while (next_permutation(ord,ord+3));\t//暴力枚举三个串链接的顺序\tcout&lt;&lt;ans&lt;&lt;endl;\treturn 0;} \n\nKMP:\nint f[maxn];string S[4];int ord[3]={0,1,2};int ans=maxlongint;inline string skr(string a,string b){\tstring T=a+'$'+b;//merge a &amp; b\tint n=a.length();\tint m=b.length();\tint Len=n+m+1;\t//int j=-1;\tf[0]=-1;\tint j=-1;\tfor(int i=1;i&lt;Len;i++)\t\t{\t\t\twhile (j!=-1 &amp;&amp; T[j+1]!=T[i])\t\t\t\t\tj=f[j];\t\t\tif(T[i]==T[j+1])\t\t\t\t\tj++;\t\t\tf[i]=j;\t\t}//找next数组\tfor (int i=n+1;i&lt;Len;i++)\t\tif (f[i]==n-1) return b;//a是b的子串\tstring cur=b.substr(0,m-1-f[Len-1])+a;//b减去a的一部分前缀+a\treturn cur;}//mainint main(){\t\tcin&gt;&gt;S[0]&gt;&gt;S[1]&gt;&gt;S[2];\tdo {\t\tans=min(ans,(int)skr(skr(S[ord[0]],S[ord[1]]),S[ord[2]]).length());\t}while (next_permutation(ord,ord+3));\t//暴力枚举三个串链接的顺序\tcout&lt;&lt;ans&lt;&lt;endl;\treturn 0;}","tags":["ICPC","授课"]},{"title":"UCUG1505(L01) Assignment 1","url":"/2025/02/10/page/","content":"","tags":["TA, Processing"]}]