[{"title":"Codeforces19D Points 树套树","url":"/2022/03/18/cf19d/","content":"Codeforces 19D Points\n\nPete and Bob invented a new interesting game. Bob takes a sheet of paper and locates a Cartesian coordinate system on it as follows: point (0, 0) is located in the bottom-left corner, Ox axis is directed right, Oy axis is directed up. Pete gives Bob requests of three types:\nadd x y — on the sheet of paper Bob marks a point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is not yet marked on Bob’s sheet at the time of the request.remove x y — on the sheet of paper Bob erases the previously marked point with coordinates (x, y). For each request of this type it’s guaranteed that point (x, y) is already marked on Bob’s sheet at the time of the request.find x y — on the sheet of paper Bob finds all the marked points, lying strictly above and strictly to the right of point (x, y). Among these points Bob chooses the leftmost one, if it is not unique, he chooses the bottommost one, and gives its coordinates to Pete.Bob managed to answer the requests, when they were 10, 100 or 1000, but when their amount grew up to 2·105, Bob failed to cope. Now he needs a program that will answer all Pete’s requests. Help Bob, please!\nInput\nThe first input line contains number n (1 ≤ n ≤ 2·105) — amount of requests. Then there follow n lines — descriptions of the requests. add x y describes the request to add a point, remove x y — the request to erase a point, find x y — the request to find the bottom-left point. All the coordinates in the input file are non-negative and don’t exceed 109.\nOutput\nFor each request of type find x y output in a separate line the answer to it — coordinates of the bottommost among the leftmost marked points, lying strictly above and to the right of point (x, y). If there are no points strictly above and to the right of point (x, y), output -1.\nExample\nInput\n7\nadd 1 1\nadd 3 4\nfind 0 0\nremove 1 1\nfind 0 0\nadd 1 1\nfind 0 0\nOutput\n1 1\n3 4\n1 1\nInput\n13\nadd 5 5\nadd 5 6\nadd 5 7\nadd 6 5\nadd 6 6\nadd 6 7\nadd 7 5\nadd 7 6\nadd 7 7\nfind 6 6\nremove 7 7\nfind 6 6\nfind 4 4\nOutput\n7 7\n-1\n5 5\n\n题目大意\n在平面直角坐标系上进行一堆骚操作。Add表示添加(x,y) Remove删除(x,y) Find(x,y)表示查询(x,y)右边的最左边的上面的最下面那个点……\n题解\n\n建一棵线段树，每个叶子节点维护一棵平衡树，平衡树里记录横坐标为x的纵坐标（横坐标较大我们可以先离散化），线段树维护横坐标在这个区间里的纵坐标的最大值，所以查询的时候只要这个线段树结点维护的key小于我们要找到y这个区间里就没有解，在key值符合条件的情况下找横坐标最左边的一个点，找到这个横坐标再在平衡树里找恰好比y大的那个点即可。\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn (int)2e5+10#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1struct Opt{\tchar s[10];\tint x,y;}opt[maxn];struct SGT{\tint l,r,key;}T[maxn&lt;&lt;2];#define ll long longint n,a[maxn],b[maxn],c[maxn];set&lt;int&gt; S[maxn];set&lt;int&gt;::iterator it;inline void build(int o,int l,int r){\tif (l&gt;r) return ;\tT[o].l=l;T[o].r=r;T[o].key=-1;\tif (l==r)return ;\tint mid=(l+r)&gt;&gt;1;\tbuild(lson,l,mid);build(rson,mid+1,r);\tT[o].key=max(T[lson].key,T[rson].key);}inline void update(int o,int x){\tint mid=(T[o].l+T[o].r)&gt;&gt;1;\tif (T[o].l==T[o].r &amp;&amp; T[o].l==x)\t{\t\tif (S[T[o].l].size())\t\t{\t\t\tit=(--S[T[o].l].end());\t\t\tT[o].key=*it;\t\t}\t\telse T[o].key=-1;\t\treturn ;\t}\tif (mid&gt;=x) update(lson,x);\telse update(rson,x);\tT[o].key=max(T[lson].key,T[rson].key);}inline int query(int o,int x,int y){\tif (T[o].r&lt;=x) return -1;\tif (T[o].key&lt;=y) return -1;\tif (T[o].l==T[o].r) return T[o].r;\tint t=query(lson,x,y);\tif (t==-1) return query(rson,x,y);\treturn t;}int cnt=0,ct2;int main(){\tcin&gt;&gt;n;\tfor (int i=1;i&lt;=n;i++)\t{\t\tscanf(\"%s%d%d\",opt[i].s,&amp;opt[i].x,&amp;opt[i].y);\t\ta[i]=opt[i].x;\t}\tsort(a+1,a+1+n);\tint t=unique(a+1,a+1+n)-a-1;\tfor (int i=1;i&lt;=n;i++) b[i]=lower_bound(a+1,a+1+t,opt[i].x)-a;\tbuild(1,1,maxn);\tfor (int i=1;i&lt;=n;i++)\t{\t\tif (opt[i].s[0]=='a')\t\t{\t\t\tS[b[i]].insert(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}else\t\tif (opt[i].s[0]=='r')\t\t{\t\t\tS[b[i]].erase(opt[i].y);\t\t\tupdate(1,b[i]);\t\t}\t\telse{\t\t\tint ans=query(1,b[i],opt[i].y);\t\t\tif (ans==-1) cout&lt;&lt;-1&lt;&lt;endl;\t\t\telse{\t\t\t\tprintf(\"%d %d\\n\",a[ans],*S[ans].upper_bound(opt[i].y));\t\t\t}\t\t}\t}}","categories":["算法竞赛"],"tags":["线段树","树套树","数据结构","Codeforces"]},{"title":"codeforces 24D Broken Robot[有后效性DP,高斯消元]","url":"/2022/03/19/cf24d/","content":"来自lyd的书，给定一张N*M的棋盘和一个初始位置，机器人位于初始位置，每次等概率地选择停在原地，向左移动一格或者向下移动一格。不能移出棋盘，求机器人从初始位置走到最后一行的任意一个位置的数学期望。（1&lt;=N,M&lt;=1,000)。\n注意很多数学期望DP都会采取倒推的方式进行我们记F[i][j]表示从(i,j)走到最后一行所需要的期望值\n位于第一列\n位于最后一列\n剩余情况\n因为每一行内部可以相互转移，所以这个dp是有后效性的，但从下一行往上一行推的过程无后效性，对于行内有后效性的转移，使用高斯消元，将下一行已经得到的数据作为已知量。通过将这些方程移项可以推出很多方程组，将它们用矩阵表示，以M=5为例\n\n观察后发现这种矩阵叫 三对角矩阵每一行消元只需要直接用下一行相邻的数据进行一次消元就行了，复杂度是线性的，加上每一行往上的无后效性递推，总体的复杂度是O(NM)。注意到M=1的时候要进行特殊处理，将第一个方程带入消元后发现每一行等于下一行的期望+2。在消元过程中很多细节的加加减减和系数处理都要在纸上列出算式消元后才能处理，要注意。\n\ndouble f[maxn],a[maxn][maxn],b[maxn];int n,m,x,y; void gauss(){\tfor (int i=1;i&lt;m;i++)\t{\t\tdouble rt=a[i+1][i]/a[i][i];\t\ta[i+1][i]-=rt*a[i][i];\t\ta[i+1][i+1]-=rt*a[i][i+1];\t\tb[i+1]-=rt*b[i];\t}\tf[m]=b[m]/a[m][m];\tfor (int i=m-1;i&gt;=1;i--)\t{\t\tf[i]=(b[i]-f[i+1]*a[i][i+1])/a[i][i];\t}}//mainint main(){\t//freopen(\"Untitled.txt.in\",\"r\",stdin);\t//freopen(\"Untitled.txt.out\",\"w\",stdout);\tios::sync_with_stdio(false);\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;\tif (m==1)\t{\t\tdouble ans= (double) (n-x) *2;\t\tcout&lt;&lt;ans&lt;&lt;endl;\t\treturn 0;\t}\tfor (int i=n-1;i&gt;=x;i--)\t{\t\ta[1][1]=(double)-2/3;\t\ta[1][2]=(double)1/3;\t\ta[m][m-1]=(double)1/3;\t\ta[m][m]=(double)-2/3;\t\tb[1]=(double)((double)-1/3)*f[1]-1;\t\tb[m]=(double)((double)-1/3)*f[m]-1;\t\tfor (int j=2;j&lt;m;j++)\t\t{\t\t\ta[j][j-1]=a[j][j+1]=(double)1/4;\t\t\ta[j][j]=(double)-3/4;\t\t\tb[j]=(double)((double)-1/4)*f[j]-1;\t\t}\t\tgauss();\t\t}\t\tcout&lt;&lt;setprecision(10)&lt;&lt;f[y]&lt;&lt;endl;\treturn 0;}","categories":["算法竞赛"],"tags":["Codeforces","动态规划","有后效性动态规划","高斯消元"]},{"title":"Javascript在宿主软件中演奏软件乐器","url":"/2022/03/18/Javascript%E5%9C%A8%E5%AE%BF%E4%B8%BB%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%BC%94%E5%A5%8F%E8%BD%AF%E4%BB%B6%E4%B9%90%E5%99%A8/","content":"JS与Logic Pro X这样的编曲宿主软件实现通信，听起来就是一个很酷的功能，这意味着你编曲时使用的MIDI信号完全可以由代码生成。尤其是有了p5和tf.js之类的前端库，在人机交互时可以将交互时产生的信号映射成MIDI信号生成音乐。\nWebMidi库就是一个可以实现JS与MIDI设备通信的Javascript库。相当于在浏览器和MIDI设备之间架起了一座桥梁。我们通过Macbook系统自带的虚拟MIDI设备IAC Driver可以直接与编曲软件Logic Pro进行通信。\n 在 启动台-其他中找到音频MIDI设置\n\nCommand+2打开MIDI工作室窗口，选定Bus 1端口，Apply！\n\n然后打开Logic，新建软件乐器轨道，这个时候我们通过JS写的代码就可以通过虚拟MIDI导入到Logic中了\n接下来编写代码，因为WebMidi基于http协议，我们需要把一个html文件挂到本地服务器上，然后引入WebMidi库，CDN或本地化后皆可，我这里将WebMidi本地化了\n\n\n&lt;script src=\"webmidi.iife.js\"&gt;&lt;/script&gt;\n\n然后为WebMidi的初始化绑定一个事件，初始化函数如下\n\nfunction init(){    WebMidi.enable(err=&gt;    {        if (err) console.log(err);        WebMidi.outputs.forEach(output=&gt;{          if (output.name===\"IAC Driver Bus 1\")            window.output=output        })      },true)      startLoop()//开始循环}\n注意output.name要选定你的虚拟MIDI端口，然后在startLoop中我们就可以编写MIDI数据了\n我们演奏一个音需要用到output.playNote()方法，该函数有三个参数，第一个是音高（Note），你可以选择0～127之间任意一个整数，也可以直接以字符串的形式比如\"C#4\"来代表这个音，或者传入一个Note对象。第二个参数是轨道参数，记得在Logic中配置每个乐器的轨道名。第三个参数是一个对象，对象中可以修改time,attack,duration,release等参数，和我们混音时这些参数所代表的含义基本一致。\n下面是我第一次写的曲子，苏联时期新闻联播的主题曲《Forward Time》的一个小片段，制谱参考油管视频G. Sviridov - Time, Forward! | Piano Tutorial (100,000 special)。做了一个小demo，写到了副歌，感觉效果还行。有了这个基础，去制作更有意思的与音乐有关的前端交互作品便成了可能。\n\nfunction startLoop()    {      var step=1;      var step2=1;      setInterval(()=&gt;{        if (step2/16&lt;12) {          if (step === 1 || step === 9)            output.playNote(\"E2\", 1, {duration: 200, attack: 0.8})          if (step === 3 || step === 11)            output.playNote(\"G2\", 1, {duration: 200, attack: 0.8})          if (step === 5 || step === 13)            output.playNote(\"A#2\", 1, {duration: 200, attack: 0.8})          if (step === 7 || step === 15)            output.playNote(\"C#3\", 1, {duration: 200, attack: 0.8})        }        if ((step2/16&gt;=4 &amp;&amp; step2/16&lt;5)||(step2/16&gt;=6 &amp;&amp; step2/16&lt;7))        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:1100,attack:0.9})            output.playNote(\"A#3\",2,{duration:1100,attack:0.9})            output.playNote(\"C#3\",2,{duration:1100,attack:0.9})          }        }        if (step2/16&gt;=8 &amp;&amp; step2/16&lt;9)        {          if (step===1)          {            output.playNote(\"F3\",2,{duration:300,attack:0.9})            output.playNote(\"A#3\",2,{duration:300,attack:0.9})            output.playNote(\"C#3\",2,{duration:300,attack:0.9})          }          if (step===5)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===7)          {            output.playNote(\"F3\",2,{duration:50,attack:0.7})            output.playNote(\"A#3\",2,{duration:50,attack:0.7})            output.playNote(\"C#3\",2,{duration:50,attack:0.7})          }          if (step===8)          {            output.playNote(\"F3\",2,{duration:20,attack:0.7})            output.playNote(\"A#3\",2,{duration:20,attack:0.7})            output.playNote(\"C#3\",2,{duration:20,attack:0.7})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=9 &amp;&amp; step2/16&lt;11)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }          if (step===9)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===11)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=11 &amp;&amp; step2/16&lt;12)        {          if (step===1)          {            output.playNote(\"G3\",2,{duration:40,attack:0.9})            output.playNote(\"C4\",2,{duration:40,attack:0.9})            output.playNote(\"E4\",2,{duration:40,attack:0.9})          }          if (step===3)          {            output.playNote(\"F3\",2,{duration:800,attack:0.9})            output.playNote(\"A#3\",2,{duration:800,attack:0.9})            output.playNote(\"C#3\",2,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=12 &amp;&amp; step2/16&lt;18)        {          if (step%2===1)          {            output.playNote(\"F#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})            output.playNote(\"C#4\",1,{duration:800,attack:0.9})          }        }        if (step2/16&gt;=14 &amp;&amp; step2/16&lt;15)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=15 &amp;&amp; step2/16&lt;16)        {          if (step===1) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1)          {            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=16 &amp;&amp; step2/16&lt;17)        {          if (step===1) {            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=17 &amp;&amp; step2/16&lt;18)        {          if (step===1) {            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#4\", 2, {duration: 1500, attack: 0.9})          }          if (step===5) {            output.playNote(\"F4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})          }          if (step===9) {            output.playNote(\"F#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#4\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          }          if (step===13)          {            output.playNote(\"A#4\", 2, {duration: 800, attack: 0.9})            output.playNote(\"C#5\", 2, {duration: 800, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 800, attack: 0.9})          }          if (step===16)          {            output.playNote(\"C#5\", 2, {duration: 300, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 300, attack: 0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;20)        {          if (step%2===1)          {            output.playNote(\"A#2\",1,{duration:100,attack:0.9})            output.playNote(\"D#3\",1,{duration:100,attack:0.9})            output.playNote(\"F#3\",1,{duration:100,attack:0.9})          }        }        if (step2/16&gt;=18 &amp;&amp; step2/16&lt;19)        {          if (step===1){          output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})          output.playNote(\"F#6\", 2, {duration: 1500, attack: 0.9})        }}        if (step2/16&gt;=19 &amp;&amp; step2/16&lt;20)        {          if (step===1){            output.playNote(\"D#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"D#6\", 2, {duration: 1500, attack: 0.9})          }          if (step===9){            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"A#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F6\", 2, {duration: 1500, attack: 0.9})          }        }        if (step2/16&gt;=20 &amp;&amp; step2/16&lt;21)        {          if (step===1){            output.playNote(\"C#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"F5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"G#5\", 2, {duration: 1500, attack: 0.9})            output.playNote(\"C#6\", 2, {duration: 1500, attack: 0.9})          }}        if (step2/16&gt;=20 )        {          if (step%2===1)          {            output.playNote(\"C#2\",1,{duration:100,attack:0.9})            output.playNote(\"C#3\",1,{duration:100,attack:0.9})          }        }step++;        if (step&gt;16)step=1;        step2++;       // step2++;        //if (step2&gt;32) step2=1      },100)    }","categories":["大前端"],"tags":["前端","Javascript","音乐","编曲"]},{"title":"hello-world","url":"/2022/03/18/hello-world/","content":"好像有那么几年不写blog了...为了督促自己继续努力刷题/学习还是在这里开了一个，github.io真的方便，会在这里记录一些学习的历程和各种碎碎念。那么继续温柔地推翻这个世界吧～\n#include &lt;bits/stdc++.h&gt;int main(){    std:cout&lt;&lt;\"Hello World\"&lt;&lt;endl;}","categories":["生活和碎碎念"],"tags":["碎碎念"]},{"title":"浙工大校赛-puzzle-Hash","url":"/2022/03/22/22-3-puzzle/","content":"\n题目大意\n\n    给三个长度为n(1&lt;=n&lt;=100 000)的数组A,B,C。可以将A数组或者B数组左移，每次移动记一次操作，问最少多少次操作可以使得Ai+Bi=Ci，否则扣-1。\n\n题解\n\n 比赛的时候脑子抽了...推了一个非充要条件，然后看有点假，想想会不会是字符串相关的题，然后去做核酸了。\n\n\n    后来发现很假，直接环形哈希就完事儿了。带上map复杂度是的。\n\n//This amazing code is written by Primo.Jay.Pan From CUC//Any questions please contact me//QQ:898021802//Mail: primojpan@gmail.com//.    primojaypan@cuc.edu.cn// Untitled 3.txt// Created by Primo Jay Pan on 2022/3/22.//While (true) RP++;//head#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#include &lt;csignal&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define ull unsigned long long#define pb push_back#define mp make_pair#define pii pair&lt;int,int&gt;#define pll pair&lt;ll,ll&gt;#define INF 0x3f3f3f3f#define maxlongint 2147483647#define maxint 32767#define pi(double)acos(-1.0)#define eps 1e-9#define MID ((l+r)&gt;&gt;1)#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)//clear the array#define cla(a) memset(a,0,sizeof(a))#define clb(a) memset(a,INF,sizeof(a))#define clc(a) memset(a,-1,sizeof(a))using namespace std;const ull mod=998244353;const int maxn =100010; ull A[maxn],B[maxn],C[maxn],base[maxn];map&lt;ull , int &gt; MP;int n;inline void init(){\tbase[0]=1;\tfor (int i=1;i&lt;=n;i++)\t\tbase[i]=base[i-1]*mod;\t}int ans=mod;//mainint main(){\t//freopen(\"Untitled 3.txt.in\",\"r\",stdin);\t//freopen(\"Untitled 3.txt.out\",\"w\",stdout);\tcin&gt;&gt;n;\tinit();\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;A[i];\t\tA[i]=A[i-1]*mod+A[i];\t}\tfor (int i=1;i&lt;=n;i++)\t{\t\tcin&gt;&gt;B[i];\t\tB[i]=B[i-1]*mod+B[i];\t}\tfor (int i=1;i&lt;=n;i++)\t\t{\t\t\tcin&gt;&gt;C[i];\t\t\tC[i]=C[i-1]*mod+C[i];\t\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(A[n]-A[i]*base[n-i])*base[i]+A[i];\t\tMP[cur]=i;//A左移动i位\t}\tfor (int i=0;i&lt;n;i++)\t{\t\tull cur=(B[n]-B[i]*base[n-i])*base[i]+B[i];//B左移动n位\t\tif (MP.count(C[n]-cur))\t\t\tans=min(ans,MP[C[n]-cur]+i);\t\t\t}\tcout&lt;&lt;((ans==mod)?-1:ans)&lt;&lt;endl;\treturn 0;}/*Test Data1:Test Data2:*/\n\n\n","categories":["算法竞赛"],"tags":["Hash","暴力","比赛"]},{"title":"React学习笔记[1]","url":"/2022/03/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","content":"\n    待填坑\n","categories":["大前端"],"tags":["Javascript","大前端","React"]}]